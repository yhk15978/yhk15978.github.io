[{"title":"浅谈vue原理","date":"2019-06-22T02:04:45.165Z","path":"/posts/1a123/","text":"浅谈vue原理 数据驱动当数据发生改变时，视图也会进行更新，这叫做数据驱动，也就是数据驱动视图 深入响应式原理数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新 双向数据绑定原理当我们使用 v-model 指令绑定了表单元素时，那么我们可以在视图直接获得数据，当视图发生改变时，数据也会进行更新综上： 三者都是应用了同一个底层原理，这个底层原理由es5的 Object.defineProperty 属性来提供 Object.defineProperty(obj, prop, descriptor)该方法允许精确添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，能够在属性枚举期间呈现出来（for…in 或 Object.keys 方法）， 这些属性的值可以被改变，也可以被删除。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的。obj要在其上定义属性的对象。prop要定义或修改的属性的名称。descriptor将被定义或修改的属性描述符。返回值被传递给函数的对象。对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。数据描述符和存取描述符均具有以下可选键值(默认值是在使用Object.defineProperty()定义属性的情况下)：configurable当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。enumerable当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。数据描述符同时具有以下可选键值：value该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。writable当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。存取描述符同时具有以下可选键值：get一个给属性提供 getter 的方法，如果没有 getter 则为undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为undefined。 set一个给属性提供 setter的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。 12345678910111213141516var input = document.querySelector('input');var p = document.querySelector('p');var obj = { name: \"\", }Object.defineProperty(obj, \"name\", { get() { return \"你好\"; }, set(val) { p.innerHTML = val; } })input.oninput = function () { obj.name= this.value;} vue中底层原理的实现主要是依赖 存储器（ getter/setter ） 我们利用了数据劫持和事件的发布订阅来实现双向数据绑定，当我们在vue data选项中定义数据时，vue会通过观察者对象（ observer ）将data选项中的所有key，经过Object.defineProperty 的getter 和setter进行设置，当我们通过 v-model指令绑定元素是， 自动触发getter,getter会返回一个初始值，这样我们在视图中就可以看到数据了，当视图中内容改变时，会触发setter,setter会通知vue，视图已经进行了更新，vue会重新生成 虚拟DOM , 继而通过 新旧 虚拟DOM 对比， 生成patch对象，再将patch对应渲染到视图中 Vue.set/this.$set 的原理（ 数组的下标和length不响应 ） 12var vm = new Vue({ data:{ a:1 } }) // `vm.a` 是响应式的 vm.b = 2 // `vm.b` 是非响应式的 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用Vue.set(object, propertyName, value)方法向嵌套对象添加响应式属性。例如： 1Vue.set(vm.someObject, 'b', 2) 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set方法的别名： 1this.$set(this.someObject,'b',2) 有时你可能需要为已有对象赋值多个新属性，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。 12// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 }) Object.assign()： 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 12345678910const target = { a: 1, b: 2 };const source = { b: 4, c: 5 };const returnedTarget = Object.assign(target, source);console.log(target);// expected output: Object { a: 1, b: 4, c: 5 }console.log(returnedTarget);// expected output: Object { a: 1, b: 4, c: 5 } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"}]},{"title":"框架级的数据请求","date":"2019-06-22T01:44:14.166Z","path":"/posts/1/","text":"框架级的数据请求1. axios(第三方库)axios get: 12345678&lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;button @click=\"getMData\"&gt;get - mock - json&lt;/button&gt; &lt;button @click=\"getOnLineData\"&gt;get - backend online- api&lt;/button&gt; &lt;button @click=\"getMPhpData\"&gt;get - myself - php -api&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950new Vue({ el: \"#app\", methods: { getMData() { axios({ url: \"../data/data.json\", method: \"GET\" }) .then(res => { console.log(res) }) .catch(error => conosle.log(error)) }, getOnLineData() { axios({ url: \"https://m.maizuo.com/gateway\", method: \"GET\", params: { 'cityId': 440100, 'pageNum': 1, 'pageSize': 20, 'type': 1, 'k': 6848113, }, headers: { 'X-Client-Info': '{\"a\":\"3000\",\"ch\":\"1002\",\"v\":\"5.0.4\",\"e\":\"15610873798997956485756\"}', 'X-Host': 'mall.film-ticket.film.list' } }) .then(res => { console.log(res) }) .catch(error => conosle.log(error)) }, getMPhpData() { axios({ url: 'http://localhost:8080/get.php', method: 'GET', params: { a: 1, b: 2 } }) .then(res => { console.log(res) }) .catch(error => conosle.log(error)) } }}) axios post:123456789101112131415161718192021222324252627282930new Vue({ el: \"#app\", methods: { postData() { var params = new URLSearchParams() //得到params对象，用来接收参数 // params.append( key, value ) key就是参数名，value就是参数值 params.append('a', 2) params.append('b', 2) axios({ url: \"http://localhost:8080/post.php\", method: \"POST\", // data:{ // a:2, // b:2 // }后台不能正常接收数据，要处理未处理的数据才能返回 data: params, headers: { 'Content-Type': \"application/x-www-form-urlencoded\" //请求头设置为表单提交的请求头 } }) .then(res => { console.log(res) }) .catch(err => { console.log(err) }) } }}) 2. fetch ( javascript 原生提供 )fetch是原生javascript提供的 ， 所以它 可以当做全局变量使用 ，它是挂载在window对象身上的 fetch get&post: 1234&lt;div id=\"app\"&gt; &lt;button @click=\"getData\"&gt; get &lt;/button&gt; &lt;button @click=\"postData\"&gt; post &lt;/button&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839new Vue({ el: '#app', methods: { getData() { fetch('http://localhost:8080/get.php?a=1&b=2', { method: 'GET', }).then(res => res.json())//对数据进行格式化 .then((data) => { console.log(data) }) .catch(err => { console.log(err) }) }, postData() { fetch('http://localhost:8080/post.php', { method: 'POST', // mode: 'cors', // headers: { // 'content-type': 'application/json' // }, // body:JSON.stringify({a:1,b:2})//MDN中案例，无效 headers: new Headers({ 'Content-Type': 'application/x-www-form-urlencoded' // 指定提交方式为表单提交 }), body: new URLSearchParams([ [\"a\", 1], [\"b\", 2] ]).toString() }).then(res => res.json()) .then((data) => { console.log(data) }) .catch(err => { console.log(err) }) } }}) fetch要手动进行一次数据格式化，但是axios是内部进行了数据的格式化 fetch get 方法请求数据，参数要直接连接在url上 fetch 格式化数据 有三种 处理方法 .json() 格式化 json 类型数据， 将 json类型 string 转换成 json 对象 .text() 格式化文本 .blob() 格式化二进制数据 fetch 如果按照官网文档书写post请求，也有坑， 携带数据出现了问题 fetch post处理 设置请求头 通过 new URLSearchPrams 来携带参数 查看更多在MDN 3. vue这边的数据请求的发展 vue-resource ( Vue 以前自己封装使用的请求类库 ) ，但是 vue-resource作者已经放弃更新了 vue-resource 作者推荐我们使用 axios vue-resource 用法 和 axios 相似度 90% + vue2.0我们基本上使用的都是 fetch / axios vue-resource 是有jsonp的 vue-resource 如果在vue中使用，是挂载当前的 实例（ 组件 ） 的$http属性身上的 举例 this.$http( options ) this.$http.get() this.$http.post vue-resource 下载安装引入 vue1.x 推荐 支持jsonp使用: 返回的是promise对象 this.$http.get('url地址?key=value&key=value').then(succFN,errorFn) this.$http.get('url地址',{配置}).then(succFN,errorFn) this.$http.post('url地址',{数据},{配置}).then(succFN,errorFn) this.$http.jsonp('url地址',{配置}).then(succFN,errorFn) params:{ //携带参数 wd:'bulala' }, jsonp:'cb', //约束回调函数的key, jsonpCallback:'show',//回调函数名 请求: body: post需要携带的数据 支持string a=1&b=2 对象 URLSearchParams 类型 new Xxx() -> x.set(key,value) params: {key:value} 携带数据 get headers: {} 携带请求头 method：’get’ get/post/….. string timeout: number 超时 progress：fn 进度 credentials: false 是否携带跨源凭证 emulateJSON：true post请求是需要携带的请求头 jsonp:’回调函数键’ 默认是callback响应： body 返回的数据 对象 (JSONP.parse) bodyText 返回的数据 文本格式 toString axios 下载安装引入 vue2.x只有推荐 支持jsonp ?? axios({ url: 地址 method: 提交方法 get/post/put…….. params: get提交参数 data: post提交参数 参数==URLSearchParams new URLSearchParams().set(key,value) timeout:超时间 headers： 请求头})拦截器 interceptor在 then 和 catch 之前我们想做的事 axios 下载安装引入 vue2.x推荐希望可以this.$http 去使用axios，需要 配置: Vue.prototype.$http=axios; this.$http|axios({配置}).then(成功回调(res)).catch(失败回调(res))this.$http|axios.get(url,{配置}).then(成功回调(res)).catch(失败回调(res))this.$http|axios.post(url,pollfill).then(成功回调(res)).catch(失败回调(res)) post请求: pollfill = new URLSearchParams() -> params.append(‘a’, 111); this.$http|axios.post(url,pollfill).then(成功回调(res)).catch(失败回调(res)) this.$http|axios({ url:'', method:'post', data:pollfill })配置: url:’’ 地址 method: ‘’ 提交姿势 params：{} get提交的数据 data:{} post提交数据res: data: 数据 4. axios 和 fetch 没有jsonp 数据请求类型的 axios 和 fetch 都是promise axios会对我们请求来的结果进行再一次的封装（ 让安全性提高 ） ajax和axios、fetch的区别 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"数据请求","slug":"数据请求","permalink":"https://yhk15978.github.io/tags/数据请求/"}]},{"title":"vue和其他框架对比","date":"2019-06-22T01:39:05.770Z","path":"/posts/234w1/","text":"vue和其他框架对比ReactReact 和 Vue 有许多相似之处，它们都有： 使用 Virtual DOM 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。 运行时性能React 和 Vue 都是非常快的，所以速度并不是在它们之中做选择的决定性因素。对于具体的数据表现，可以移步这个[第三方 benchmark](https://stefankrause.net/js-frameworks-benchmark8/table.html)，它专注于渲染/更新非常简单的组件树的真实性能。优化 在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。 如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。 然而，使用PureComponent和shouldComponentUpdate时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得 React 中的组件优化伴随着相当的心智负担。 在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了shouldComponentUpdate，并且没有上述的子树问题限制。 Vue 的这个特点使得开发者不再需要考虑此类优化，从而能够更好地专注于应用本身。 HTML & CSS 在 React 中，一切都是 JavaScript。不仅仅是 HTML 可以用 JSX 来表达，现在的潮流也越来越多地将 CSS 也纳入到 JavaScript 中来处理。这类方案有其优点，但也存在一些不是每个开发者都能接受的取舍。 Vue 的整体思想是拥抱经典的 Web 技术，并在其上进行扩展。我们下面会详细分析一下。 JSX vs Templates在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。使用 JSX 的渲染函数有下面这些优势： 你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。比如你可以使用临时变量、JS 自带的流程控制、以及直接引用当前 JS 作用域中的值等等。 开发工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的 (比如，linting、类型检查、编辑器的自动完成)。 事实上 Vue 也提供了渲染函数，甚至支持 JSX。然而，我们默认推荐的还是模板。任何合乎规范的 HTML 都是合法的 Vue 模板，这也带来了一些特有的优势： 对于很多习惯了 HTML 的开发者来说，模板比起 JSX 读写起来更自然。这里当然有主观偏好的成分，但如果这种区别会导致开发效率的提升，那么它就有客观的价值存在。 基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。 你甚至可以使用其他模板预处理器，比如 Pug 来书写 Vue 的模板。 有些开发者认为模板意味着需要学习额外的 DSL (Domain-Specific Language 领域特定语言) 才能进行开发——我们认为这种区别是比较肤浅的。首先，JSX 并不是没有学习成本的——它是基于 JS 之上的一套额外语法。同时，正如同熟悉 JS 的人学习 JSX 会很容易一样，熟悉 HTML 的人学习 Vue 的模板语法也是很容易的。最后，DSL 的存在使得我们可以让开发者用更少的代码做更多的事，比如 `v-on` 的各种修饰符，在 JSX 中实现对应的功能会需要多得多的代码。 更抽象一点来看，我们可以把组件区分为两类：一类是偏视图表现的 (presentational)，一类则是偏逻辑的 (logical)。我们推荐在前者中使用模板，在后者中使用 JSX 或渲染函数。这两类组件的比例会根据应用类型的不同有所变化，但整体来说我们发现表现类的组件远远多于逻辑类组件。 组件作用域内的 CSS 除非你把组件分布在多个文件上 (例如 CSS Modules)，CSS 作用域在 React 中是通过 CSS-in-JS 的方案实现的 (比如 styled-components、glamorous 和 emotion)。这引入了一个新的面向组件的样式范例，它和普通的 CSS 撰写过程是有区别的。另外，虽然在构建时将 CSS 提取到一个单独的样式表是支持的，但 bundle 里通常还是需要一个运行时程序来让这些样式生效。当你能够利用 JavaScript 灵活处理样式的同时，也需要权衡 bundle 的尺寸和运行时的开销。 如果你是一个 CSS-in-JS 的爱好者，许多主流的 CSS-in-JS 库也都支持 Vue (比如 styled-components-vue 和vue-emotion)。这里 React 和 Vue 主要的区别是，Vue 设置样式的默认方法是单文件组件里类似 style 的标签。 单文件组件让你可以在同一个文件里完全控制 CSS，将其作为组件代码的一部分。 123 @media (min-width: 250px) { .list-container:hover { background: orange; } } 这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域，编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover。 最后，Vue 的单文件组件里的样式设置是非常灵活的。通过 vue-loader，你可以使用任意预处理器、后处理器，甚至深度集成 CSS Modules——全部都在 标签内。 #### 规模 向上扩展 Vue 和 React 都提供了强大的路由来应对大型应用。React 社区在状态管理方面非常有创新精神 (比如 Flux、Redux)，而这些状态管理模式甚至 `Redux 本身`也可以非常容易的集成在 Vue 应用中。实际上，Vue 更进一步地采用了这种模式 (`Vuex`)，更加深入集成 Vue 的状态管理解决方案 Vuex 相信能为你带来更好的开发体验。 两者另一个重要差异是，Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。 最后，Vue 提供了 `Vue-cli` 脚手架，能让你非常容易地构建项目，包含了 `Webpack`，`Browserify`，甚至 `no build system`。React 在这方面也提供了 `create-react-app`，但是现在还存在一些局限性： * 它不允许在项目生成时进行任何配置，而 Vue 支持 `Yeoman-like` 定制。 * 它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。 * 它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。如果阅读更多关于不同的设计理念。 向下扩展React 学习曲线陡峭，在你开始学 React 前，你需要知道 JSX 和 ES2015，因为许多示例用的是这些语法。你需要学习构建系统，虽然你在技术上可以用 Babel 来实时编译代码，但是这并不推荐用于生产环境。就像 Vue 向上扩展好比 React 一样，Vue 向下扩展后就类似于 jQuery。你只要把如下标签放到页面就可以运行：然后你就可以编写 Vue 代码并应用到生产中，你只要用 min 版 Vue 文件替换掉就不用担心其他的性能问题。 由于起步阶段不需学 JSX，ES2015 以及构建系统，所以开发者只需不到一天的时间阅读指南就可以建立简单的应用程序。 原生渲染React Native 能使你用相同的组件模型编写有本地渲染能力的 APP (iOS 和 Android)。能同时跨多平台开发，对开发者是非常棒的。相应地，Vue 和 Weex 会进行官方合作，Weex 是阿里巴巴发起的跨平台用户界面开发框架，同时也正在 Apache 基金会进行项目孵化，Weex 允许你使用 Vue 语法开发不仅仅可以运行在浏览器端，还能被用于开发 iOS 和 Android 上的原生应用的组件。 在现在，Weex 还在积极发展，成熟度也不能和 React Native 相抗衡。但是，Weex 的发展是由世界上最大的电子商务企业的需求在驱动，Vue 团队也会和 Weex 团队积极合作确保为开发者带来良好的开发体验。 另一个选择是 NativeScript-Vue，一个用 Vue.js 构建完全原生应用的 NativeScript 插件。 MobXMobx 在 React 社区很流行，实际上在 Vue 也采用了几乎相同的反应系统。在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue，所以如果你习惯组合使用它们，那么选择 Vue 会更合理。 Preact 和其它类 React 库类 React 的库们往往尽可能地与 React 共享 API 和生态。因此上述比较对它们来说也同样适用。它们和 React 的不同往往在于更小的生态。因为这些库无法 100% 兼容 React 生态中的全部，部分工具和辅助库也可能无法使用。或者即使看上去能工作，但也有可能随时发生不兼容，除非你用的这个类 React 库官方与 React 保持严格一致。 AngularJS (Angular 1)Vue 的一些语法和 AngularJS 的很相似 (例如 v-if vs ng-if)。因为 AngularJS 是 Vue 早期开发的灵感来源。然而，AngularJS 中存在的许多问题，在 Vue 中已经得到解决。 复杂性在 API 与设计两方面上 Vue.js 都比 AngularJS 简单得多，因此你可以快速地掌握它的全部特性并投入开发。 灵活性和模块化Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 AngularJS 制定的规则，这让 Vue 能适用于各种项目。我们知道把决定权交给你是非常必要的。 这也是为什么我们提供了一个基于 Vue.js 进行快速开发的完整系统。Vue CLI 旨在成为 Vue 生态系统中标准的基础工具。它使得多样化的构建工具通过妥善的默认配置无缝协作在一起。这样你就可以专注在应用本身，而不会在配置上花费太多时间。同时，它也提供了根据实际需求调整每个工具配置的灵活性。 数据绑定AngularJS 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。 指令与组件Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。 在 AngularJS 中，当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环 (digest cycle) 可能要运行多次。AngularJS 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。 Vue 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系。 有意思的是，Angular 和 Vue 用相似的设计解决了一些 AngularJS 中存在的问题。 Angular (原本的 Angular 2)我们将新的 Angular 独立开来讨论，因为它是一个和 AngularJS 完全不同的框架。例如：它具有优秀的组件系统，并且许多实现已经完全重写，API 也完全改变了。 TypeScriptAngular 事实上必须用 TypeScript 来开发，因为它的文档和学习资源几乎全部是面向 TS 的。TS 有很多好处——静态类型检查在大规模的应用中非常有用，同时对于 Java 和 C# 背景的开发者也是非常提升开发效率的。 然而，并不是所有人都想用 TS——在中小型规模的项目中，引入 TS 可能并不会带来太多明显的优势。在这些情况下，用 Vue 会是更好的选择，因为在不用 TS 的情况下使用 Angular 会很有挑战性。 最后，虽然 Vue 和 TS 的整合可能不如 Angular 那么深入，我们也提供了官方的 类型声明 和 组件装饰器，并且知道有大量用户在生产环境中使用 Vue + TS 的组合。我们也和微软的 TS / VSCode 团队进行着积极的合作，目标是为 Vue + TS 用户提供更好的类型检查和 IDE 开发体验。 运行时性能这两个框架都很快，有非常类似的 benchmark 数据。你可以浏览具体的数据做更细粒度的对比，不过速度应该不是决定性的因素。 体积在体积方面，最近的 Angular 版本中在使用了 AOT 和 tree-shaking 技术后使得最终的代码体积减小了许多。但即使如此，一个包含了 Vuex + Vue Router 的 Vue 项目 (gzip 之后 30kB) 相比使用了这些优化的 angular-cli 生成的默认项目尺寸 (~65KB) 还是要小得多。 灵活性Vue 相比于 Angular 更加灵活，Vue 官方提供了构建工具来协助你构建项目，但它并不限制你去如何组织你的应用代码。有人可能喜欢有严格的代码组织规范，但也有开发者喜欢更灵活自由的方式。 学习曲线要学习 Vue，你只需要有良好的 HTML 和 JavaScript 基础。有了这些基本的技能，你就可以非常快速地通过阅读 指南 投入开发。 Angular 的学习曲线是非常陡峭的——作为一个框架，它的 API 面积比起 Vue 要大得多，你也因此需要理解更多的概念才能开始有效率地工作。当然，Angular 本身的复杂度是因为它的设计目标就是只针对大型的复杂应用；但不可否认的是，这也使得它对于经验不甚丰富的开发者相当的不友好。 EmberEmber 是一个全能框架。它提供了大量的约定，一旦你熟悉了它们，开发会变得很高效。不过，这也意味着学习曲线较高，而且并不灵活。这意味着在框架和库 (加上一系列松散耦合的工具) 之间做权衡选择。后者会更自由，但是也要求你做更多架构上的决定。 也就是说，我们最好比较的是 Vue 内核和 Ember 的模板与数据模型层： Vue 在普通 JavaScript 对象上建立响应，提供自动化的计算属性。在 Ember 中需要将所有东西放在 Ember 对象内，并且手工为计算属性声明依赖。 Vue 的模板语法可以用全功能的 JavaScript 表达式，而 Handlebars 的语法和帮助函数相比来说非常受限。 在性能上，Vue 比 Ember 好很多，即使是 Ember 3.x 的最新 Glimmer 引擎。Vue 能够自动批量更新，而 Ember 在性能敏感的场景时需要手动管理。 KnockoutKnockout 是 MVVM 领域内的先驱，并且追踪依赖。它的响应系统和 Vue 也很相似。它在浏览器支持以及其他方面的表现也是让人印象深刻的。它最低能支持到 IE6，而 Vue 最低只能支持到 IE9。 随着时间的推移，Knockout 的发展已有所放缓，并且略显有点老旧了。比如，它的组件系统缺少完备的生命周期事件方法，尽管这些在现在是非常常见的。以及相比于 Vue 调用子组件的接口它的方法显得有点笨重。 如果你有兴趣研究，你还会发现二者在接口设计的理念上是不同的。这可以通过各自创建的 simple Todo List 体现出来。或许有点主观，但是很多人认为 Vue 的 API 接口更简单结构更优雅。 PolymerPolymer 是另一个由谷歌赞助的项目，事实上也是 Vue 的一个灵感来源。Vue 的组件可以粗略的类比于 Polymer 的自定义元素，并且两者具有相似的开发风格。最大的不同之处在于，Polymer 是基于最新版的 Web Components 标准之上，并且需要重量级的 polyfills 来帮助工作 (性能下降)，浏览器本身并不支持这些功能。相比而言，Vue 在支持到 IE9 的情况下并不需要依赖 polyfills 来工作。 在 Polymer 版本中，为了弥补性能，团队非常有限的使用数据绑定系统。例如，在 Polymer 中唯一支持的表达式只有布尔值否定和单一的方法调用，它的 computed 方法的实现也并不是很灵活。 RiotRiot 3.0 提供了一个类似于基于组件的开发模型 (在 Riot 中称之为 Tag)，它提供了小巧精美的 API。Riot 和 Vue 在设计理念上可能有许多相似处。尽管相比 Riot ，Vue 要显得重一点，Vue 还是有很多显著优势的： 更好的性能。Riot 使用了 遍历 DOM 树 而不是虚拟 DOM，但实际上用的还是脏检查机制，因此和 AngularJS 患有相同的性能问题。 更多成熟工具的支持。Vue 提供官方支持 webpack 和 Browserify，而 Riot 是依靠社区来建立集成系统。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"}]},{"title":"npm scripts  npm脚本","date":"2019-06-21T12:38:25.690Z","path":"/posts/4a17b235/","text":"转载自：阮一峰http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html 一、什么是 npm 脚本？npm 允许在package.json文件里面，使用scripts字段定义脚本命令。 12345{// ...\"scripts\": {\"build\": \"node build.js\"}} 上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。 命令行下使用npm run命令，就可以执行这段脚本。 123$ npm run build# 等同于执行$ node build.js 这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多。 123项目的相关脚本，可以集中在一个地方。不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。可以利用 npm 提供的很多辅助功能。 查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。 1$ npm run 二、原理npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。 比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。 这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有Mocha，只要直接写mocha test就可以了。 1\"test\": \"mocha test\" 而不用写成下面这样。 1\"test\": \"./node_modules/.bin/mocha test\" 由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。 三、通配符由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。 12\"lint\": \"jshint *.js\"\"lint\": \"jshint **/*.js\" 上面代码中，*表示任意文件名，**表示任意一层子目录。如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。 1\"test\": \"tap test/\\*.js\" 四、传参向 npm 脚本传入参数，要使用--标明 1\"lint\": \"jshint **.js\" 向上面的npm run lint命令传入参数，必须写成下面这样。 1$ npm run lint -- --reporter checkstyle > checkstyle.xml 也可以在package.json里面再封装一个命令。 12\"lint\": \"jshint **.js\",\"lint:checkstyle\": \"npm run lint -- --reporter checkstyle > checkstyle.xml\" 五、执行顺序如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。如果是并行执行（即同时的平行执行），可以使用&符号。 1$ npm run script1.js & npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号。 1$ npm run script1.js && npm run script2.js 这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。 六、默认值一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。 12\"start\":\"node sever.js\",\"install\":\"node-gyp rebuild\" 上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。 七、钩子npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。 123\"prebuild\": \"echo I run before the build script\",\"build\": \"cross-env NODE_ENV=production webpack\",\"postbuild\": \"echo I run after the build script\" 用户执行npm run build的时候，会自动按照下面的顺序执行。 1npm run prebuild && npm run build && npm run postbuild 因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。 123\"clean\": \"rimraf ./dist && mkdir dist\",\"prebuild\": \"npm run clean\",\"build\": \"cross-env NODE_ENV=production webpack\" npm 默认提供下面这些钩子 prepublish，postpublish preinstall，postinstallpreuninstall， postuninstallpreversion，postversionpretest posttestprestop，poststopprestart， poststartprerestart，postrestart 自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。 12345678910const TARGET = process.env.npm_lifecycle_event;if (TARGET === 'test') { console.log(`Running the test task!`);}if (TARGET === 'pretest') { console.log(`Running the pretest task!`);}if (TARGET === 'posttest') { console.log(`Running the posttest task!`);} 注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。 八、简写形式四个常用的 npm 脚本有简写形式。 npm start是npm run start npm stop是npm run stop的简写 npm test是npm run test的简写 npm restart是npm run stop && npm run restart && npm run start的简写 npm start、npm stop和npm restart都比较好理解，而npm restart是一个复合命令，实际上会执行三个脚本命令：stop、restart、start。具体的执行顺序如下。 prerestart prestop stop poststop restart prestart start poststart postrestart 九、变量npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。首先，通过npm_package_前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。 123456{ \"name\": \"foo\", \"version\": \"1.2.5\", \"scripts\": { \"view\": \"node view.js\" }} 那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。 123// view.jsconsole.log(process.env.npm_package_name); // fooconsole.log(process.env.npm_package_version); // 1.2.5 上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是 Bash 脚本，可以用$npm_package_name和$npm_package_version取到这两个值。 npm_package_前缀也支持嵌套的package.json字段。 1234567\"repository\": { \"type\": \"git\", \"url\": \"xxx\" }, scripts: { \"view\": \"echo $npm_package_repository_type\" } 上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。下面是另外一个例子。 12\"scripts\": { \"install\": \"foo.js\"} 上面代码中，npm_package_scripts_install变量的值等于foo.js。 然后，npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。 1\"view\": \"echo $npm_config_tag\", 注意，package.json里面的config对象，可以被环境变量覆盖。 1234{ \"name\" : \"foo\", \"config\" : { \"port\" : \"8080\" }, \"scripts\" : { \"start\" : \"node server.js\" }} 上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。 1$ npm config set foo:port 80 最后，env命令可以列出所有环境变量。 1\"env\": \"env\" 十、常用脚本示例123456789101112131415161718// 删除目录\"clean\": \"rimraf dist/*\",// 本地搭建一个 HTTP 服务\"serve\": \"http-server -p 9090 dist/\",// 打开浏览器\"open:dev\": \"opener http://localhost:9090\",// 实时刷新 \"livereload\": \"live-reload --port 9091 dist/\",// 构建 HTML 文件\"build:html\": \"jade index.jade > dist/index.html\",// 只要 CSS 文件有变动，就重新执行构建\"watch:css\": \"watch 'npm run build:css' assets/styles/\",// 只要 HTML 文件有变动，就重新执行构建\"watch:html\": \"watch 'npm run build:html' assets/html\",// 部署到 Amazon S3\"deploy:prod\": \"s3-cli sync ./dist/ s3://example-com/prod-site/\",// 构建 favicon\"build:favicon\": \"node scripts/favicon.js\", 十一、 npm scripts npm脚本 明白为什么要使用npm脚本 集中存储当前项目的所有脚本命令 npm脚本使用 npm run xxx npm多脚本执行 npm run xxx & npm run xxx npm run xxx && npm run xxx npm脚本可以简写，但是仅限一下几个npm startnpm stopnpm testnpm restart 1234567891011121314151617181920{\"name\": \"scripts\",\"version\": \"1.0.0\",\"description\": \"\",\"main\": \"index.js\",\"scripts\": {\"pretest\": \"echo pretest\",\"test\": \"echo test\",\"posttest\": \"echo posttest\",\"dev\": \"node server.js\",\"build\": \"npm run dev\",\"app\": \"node app.js\",\"yyb\": \"npm run app&npm run dev\",\"junge\": \"npm run app&&npm run dev\",\"env\": \"env\"},\"keywords\": [],\"author\": \"\",\"license\": \"ISC\"} 十一、参考链接* http://www.ruanyifeng.com/blog/2016/10/npm_scripts.htmlby ruanyifeng document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"}]},{"title":"Node.js 常用模块","date":"2019-06-21T12:26:48.145Z","path":"/posts/4a17b109/","text":"Node.js 常用模块URL url.parse(urlString[, parseQueryString[, slashesDenoteHost]]) 将url字符转成url对象 urlString 要解析的 URL 字符串。 parseQueryString 如果设为 true，则返回的 URL 对象的 query 属性会是一个使用 querystring 模块的 parse() 生成的对象。 如果设为 false，则 query 会是一个未解析未解码的字符串。 默认为 false。 slashesDenoteHost 如果设为 true，则 // 之后至下一个 / 之前的字符串会解析作为 host。 例如， //foo/bar 会解析为 {host: 'foo', pathname: '/bar'} 而不是 {pathname: '//foo/bar'}。 默认为 false。 url.format(URL[, options])将url对象转成url字符 URL 一个对象 options auth 如果序列化的URL字符串应该包含用户名和密码为true，否则为false。默认为true。 fragment 如果序列化的URL字符串应该包含分段为true，否则为false。默认为true。 search如果序列化的URL字符串应该包含搜索查询为true，否则为false。默认为true。 unicode true 如果出现在URL字符串主机元素里的Unicode字符应该被直接编码而不是使用Punycode编码为true，默认为false。 3.url.resolve(from, to)url路径的拼接，替换 from 解析时相对的基本 URL。 to要解析的超链接 URL。 例子：1234const url = require('url');url.resolve('/one/two/three', 'four'); // '/one/two/four'url.resolve('http://example.com/', '/one'); // 'http://example.com/one'url.resolve('http://example.com/one', '/two'); // 'http://example.com/two' querystring（查询字符串） querystring.stringify(obj[, sep[, eq[, options]]])解析对象部分转成URLsearch obj 要序列化为 URL 查询字符串的对象。 sep用于在查询字符串中分隔键值对的子字符串。默认值: '&'。 eq 用于在查询字符串中分隔键和值的子字符串。默认值: '='。 options encodeURIComponent 在查询字符串中将 URL 不安全字符转换为百分比编码时使用的函数。默认值: querystring.escape()。 querystring.stringify() 方法通过迭代对象的自身属性从给定的 obj 生成 URL 查询字符串1234querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });// 返回 'foo=bar&baz=qux&baz=quux&corge='querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');// 返回 'foo:bar;baz:qux' 默认情况下，查询字符串中需要百分比编码的字符将编码为 UTF-8。 如果需要其他编码，则需要指定其他 encodeURIComponent 选项： 123// 假设 gbkEncodeURIComponent 函数已存在。querystring.stringify({ w: '中文', foo: 'bar' }, null, null,{ encodeURIComponent: gbkEncodeURIComponent }); querystring.parse(str[, sep[, eq[, options]]]) 解析URLsearch部分转成对象 str 要解析的 URL 查询字符串。 sep 用于在查询字符串中分隔键值对的子字符串。默认值: '&'。 eq用于在查询字符串中分隔键和值的子字符串。默认值: '='。 options decodeURIComponent解码查询字符串中的百分比编码字符时使用的函数。默认值: querystring.unescape()。 maxKeys 指定要解析的键的最大数量。指定 0 可移除键的计数限制。默认值: 1000。 querystring.parse() 方法将 URL 查询字符串 str 解析为键值对的集合。例如，查询字符串 'foo=bar&abc=xyz&abc=123' 被解析为：1234{foo: 'bar',abc: ['xyz', '123']} querystring.parse() 方法返回的对象不是原型继承自 JavaScript Object。 这意味着典型的 Object 方法如 obj.toString()、 obj.hasOwnProperty() 等都没有定义并且不起作用。默认情况下，将假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他字符编码，则需要指定其他 decodeURIComponent 选项： 123// 假设 gbkDecodeURIComponent 函数已存在。querystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null,{ decodeURIComponent: gbkDecodeURIComponent }); querystring.escape(str) 可以将中文转成url百分比编码 strquerystring.escape() 方法以对 URL 查询字符串的特定要求进行了优化的方式对给定的 str 执行 URL 百分比编码。querystring.escape() 方法由 querystring.stringify() 使用，通常不会直接使用。 它的导出主要是为了允许应用程序代码在必要时通过将 querystring.escape 指定给替代函数来提供替换的百分比编码实现。 querystring.unescape(str)可以将url百分比编码解码 strquerystring.unescape() 方法在给定的 str 上执行 URL 百分比编码字符的解码。querystring.unescape() 方法由 querystring.parse() 使用，通常不会直接使用它。 它的导出主要是为了允许应用程序代码在必要时通过将 querystring.unescape 分配给替代函数来提供替换的解码实现。默认情况下， querystring.unescape() 方法将尝试使用 JavaScript 内置的 decodeURIComponent() 方法进行解码。 如果失败，将使用更安全的不会丢失格式错误的 URL 的等价方法。http模块 http.get(options[, callback])http.get(url[,options][, callback]) url string| url options 接受与 http.request() 相同的 options，且 method 始终设置为 GET。从原型继承的属性将被忽略。 callbackFunction 返回:http.ClientRequest由于大多数请求都是没有主体的 GET 请求，因此 Node.js 提供了这个便捷的方法。 这个方法与 http.request() 的唯一区别是它将方法设置为 GET 并自动调用 req.end()。 注意，由于 http.ClientRequest 章节中所述的原因，回调必须注意消费响应数据。callback 调用时只有一个参数，该参数是 http.IncomingMessage 的实例。获取 JSON 的示例：12345678910111213141516171819202122232425262728293031http.get('http://nodejs.cn/index.json', (res) => {const { statusCode } = res;const contentType = res.headers['content-type'];let error;if (statusCode !== 200) {error = new Error('请求失败\\n' +`状态码: ${statusCode}`);} else if (!/^application\\/json/.test(contentType)) {error = new Error('无效的 content-type.\\n' +`期望的是 application/json 但接收到的是 ${contentType}`);}if (error) {console.error(error.message);// 消费响应数据来释放内存。res.resume();return;}res.setEncoding('utf8');let rawData = '';res.on('data', (chunk) => { rawData += chunk; });res.on('end', () => {try {const parsedData = JSON.parse(rawData);console.log(parsedData);} catch (e) {console.error(e.message);}});}).on('error', (e) => {console.error(`出现错误: ${e.message}`);}); http.request(options[, callback]) http.request(url[, options][, callback]) url |url options Object protocol 使用的协议。默认值: 'http:'。 host 请求发送至的服务器的域名或 IP 地址。默认值: 'localhost'。 hostname host 的别名。为了支持 url.parse()，如果同时指定 host 和 hostname，则使用 hostname。 family number当解析 host 或 hostname 时使用的 IP 地址族。有效值为 4 或 6。如果没有指定，则同时使用 IP v4 和 v6。 port number远程服务器的端口。默认值: 80。 localAddress 为网络连接绑定的本地接口。 socketPath Unix 域套接字。如果指定了 host 或 port 之一（它们指定了 TCP 套接字），则不能使用此选项。 method 一个字符串，指定 HTTP 请求的方法。默认值: 'GET'。 path 请求的路径。应包括查询字符串（如果有）。例如 '/index.html?page=12'。当请求的路径包含非法的字符时，则抛出异常。目前只有空格被拒绝，但未来可能会有所变化。默认值: '/'。 headersObject 包含请求头的对象。 auth 基本的身份验证，即 'user:password'，用于计算授权请求头。 agent | 控制 Agent 的行为。可能的值有： undefined (默认): 对此主机和端口使用 http.globalAgent。 Agent 对象: 显式地使用传入的 Agent。 false: 使用新建的具有默认值的 Agent。 createConnection 当 agent 选项未被使用时，用来为请求生成套接字或流的函数。这可用于避免创建自定义的 Agent 类以覆盖默认的 createConnection 函数。详见 agent.createConnection()。任何双工流都是有效的返回值。 timeout: 指定套接字超时的数值，以毫秒为单位。这会在套接字被连接之前设置超时。 setHost : 指定是否自动添加 Host 请求头。默认值: true。 callback 返回: Node.js 为每个服务器维护多个连接以发出 HTTP 请求。 此函数允许显式地发出请求。url 可以是字符串或 URL 对象。 如果 url 是一个字符串，则会自动使用 url.parse() 解析它。 如果它是一个 URL 对象，则会自动转换为普通的 options 对象。如果同时指定了 url 和 options，则对象会被合并，其中 options 属性优先。可选的 callback 参数会作为单次监听器被添加到 'response' 事件。http.request() 返回 http.ClientRequest 类的实例。 ClientRequest 实例是一个可写流。 如果需要使用 POST 请求上传文件，则写入到 ClientRequest 对象。123456789101112131415161718192021222324252627282930const postData = querystring.stringify({'msg': '你好世界'});const options = {hostname: 'nodejs.cn',port: 80,path: '/upload',method: 'POST',headers: {'Content-Type': 'application/x-www-form-urlencoded','Content-Length': Buffer.byteLength(postData)}};const req = http.request(options, (res) => {console.log(`状态码: ${res.statusCode}`);console.log(`响应头: ${JSON.stringify(res.headers)}`);res.setEncoding('utf8');res.on('data', (chunk) => {console.log(`响应主体: ${chunk}`);});res.on('end', () => {console.log('响应中已无数据');});});req.on('error', (e) => {console.error(`请求遇到问题: ${e.message}`);});// 将数据写入请求主体。req.write(postData);req.end(); 注意，在示例中调用了 req.end()。 使用 http.request() 时，必须始终调用 req.end() 来表示请求的结束，即使没有数据被写入请求主体。如果在请求期间遇到任何错误（DNS 解析错误、TCP 层的错误、或实际的 HTTP 解析错误），则会在返回的请求对象上触发 'error' 事件。 与所有 'error' 事件一样，如果没有注册监听器，则会抛出错误。以下是需要注意的一些特殊的请求头。 发送 'Connection: keep-alive' 会通知 Node.js 与服务器的连接应该持续到下一个请求。 发送 'Content-Length' 请求头会禁用默认的分块编码。 发送 'Expect' 请求头会立即发送请求头。通常情况下，当发送 'Expect: 100-continue' 时，应设置超时时间和 'continue' 事件的监听器。详见 RFC2616 的第 8.2.3 节。 发送授权请求头会使用 auth 选项覆盖以计算基本的身份验证。使用 URL 作为 options 的示例：1234const options = new URL('http://abc:xyz@nodejs.cn');const req = http.request(options, (res) => {// ...}); 在成功的请求中，会按以下顺序触发以下事件： 'socket' 事件 'response' 事件 res 对象上任意次数的 'data' 事件（如果响应主体为空，则根本不会触发 'data' 事件，例如在大多数重定向中） res 对象上的 'end' 事件 'close' 事件如果出现连接错误，则触发以下事件： 'socket' 事件 'error' 事件 'close' 事件如果在连接成功之前调用 req.abort()，则按以下顺序触发以下事件： 'socket' 事件 (在这里调用 req.abort()) 'abort' 事件 'error' 事件并带上错误信息 'Error: socket hang up' 和错误码 'ECONNRESET' 'close' 事件如果在响应被接收之后调用 req.abort()，则按以下顺序触发以下事件： 'socket' 事件 'response' 事件 res 对象上任意次数的 'data' 事件 (在这里调用 req.abort()) 'abort' 事件 res 对象上的 'aborted' 事件 'close' 事件 res 对象上的 'end' 事件 res 对象上的 'close' 事件注意，设置 timeout 选项或使用 setTimeout() 函数不会中止请求或执行除添加 'timeout' 事件之外的任何操作。 http.createServer([options][, requestlistener]) 创建服务 options IncomingMessage 指定要使用的 IncomingMessage 类。用于扩展原始的 IncomingMessage。默认值:IncomingMessage。 ServerResponse 指定要使用的 ServerResponse 类。用于扩展原始 ServerResponse。默认值: ServerResponse。 requestListener 返回: 返回新建的 http.Server 实例。requestListener 是一个自动添加到 'request' 事件的函数。// server.listen 是开启监听// 第一个参数是port// 第二个参数可选 是回调server.listen(port, () => {console.log(server is running on ${port});}); 阿萨fs（文件系统） fs.readFile(path[, options], callback) 读取文件 path文件名或文件描述符。 options encoding 默认值: null。 flag 参阅支持的文件系统标志。默认值: 'r'。 callback err data异步地读取文件的全部内容。1234fs.readFile('/etc/passwd', (err, data) => {if (err) throw err;console.log(data);}); 回调会传入两个参数 (err, data)，其中 data 是文件的内容。如果没有指定 encoding，则返回原始的 buffer。如果 options 是字符串，则它指定字符编码： 1fs.readFile('/etc/passwd', 'utf8', callback); 当 path 是目录时， fs.readFile() 与 fs.readFileSync() 的行为是特定于平台的。 在 macOS、Linux 和 Windows 上，将返回错误。 在 FreeBSD 上，将返回目录内容的表示。 12345678// 在 macOS、Linux 和 Windows 上：fs.readFile('', (err, data) => {// => [Error: EISDIR: illegal operation on a directory, read ]});// 在 FreeBSD 上：fs.readFile('', (err, data) => {// => null, }); fs.readFile() 函数会缓冲整个文件。 为了最小化内存成本，尽可能通过 fs.createReadStream() 进行流式传输。 fs.writeFile(file, data[, options], callback) 写入文件 file | | | 文件名或文件描述符。 data | | | options | encoding | 默认值: 'utf8'。 mode 默认值: 0o666。 flag 参阅支持的文件系统标志。默认值: 'w'。 callback err 异步地将数据写入到一个文件，如果文件已存在则覆盖该文件。 data 可以是字符串或 buffer。如果 data 是一个 buffer，则 encoding 选项会被忽略。12345const data = new Uint8Array(Buffer.from('Node.js中文网'));fs.writeFile('文件.txt', data, (err) => {if (err) throw err;console.log('文件已被保存');}); 如果 options 是一个字符串，则它指定字符编码： 1fs.writeFile('文件.txt', 'Node.js中文网', 'utf8', callback); 在同一个文件上多次使用 fs.writeFile() 且不等待回调是不安全的。 对于这种情况，建议使用 fs.createWriteStream()。 文件描述符中英对照提交修改 任何指定的文件描述符都必须支持写入。 如果将文件描述符指定为 file，则不会自动关闭它。 写入将从文件的开头开始。例如，如果文件已经有内容 'Hello World‘ 并且新写入的内容是 'Aloha'，则该文件的内容将是 'Aloha World' 而不仅仅是 'Aloha'。 fs.rename(oldPath, newPath, callback) oldPath newPath callback err异步地将 oldPath 上的文件重命名为 newPath 提供的路径名。 如果 newPath 已存在，则覆盖它。 除了可能的异常，完成回调没有其他参数。也可参阅 rename(2)。1234fs.rename('旧文件.txt', '新文件.txt', (err) => {if (err) throw err;console.log('重命名完成');}); fs.readdir(path[, options], callback) path options encoding默认值: 'utf8'。 withFileTypes) 默认值: false。 callback err files异步的 readdir(3)。 读取目录的内容。 回调有两个参数 (err, files)，其中 files 是目录中的文件名的数组（不包括 '.' 和 '..'）。可选的 options 参数可以是指定编码的字符串，也可以是具有 encoding 属性的对象，该属性指定用于传给回调的文件名的字符编码。 如果 encoding 设置为 'buffer'，则返回的文件名是 Buffer 对象。如果 options.withFileTypes 设置为 true，则 files 数组将包含 fs.Dirent 对象。 fs.mkdir(path[, options], callback) path options recursive 默认值: false。 mode Windows 上不支持。默认值: 0o777。 callback err异步地创建目录。 除了可能的异常，完成回调没有其他参数。可选的 options 参数可以是指定模式（权限和粘滞位）的整数，也可以是具有 mode 属性和 recursive 属性（指示是否应创建父文件夹）的对象。1234// 创建 /tmp/a/apple 目录，无论是否存在 /tmp 和 /tmp/a 目录。fs.mkdir('/tmp/a/apple', { recursive: true }, (err) => {if (err) throw err;}); fs.copyFile(src, dest[, flags], callback) src要拷贝的源文件名。 dest拷贝操作的目标文件名。 flags用于拷贝操作的修饰符。默认值: 0。 callback异步地将 src 拷贝到 dest。 默认情况下，如果 dest 已经存在，则覆盖它。 除了可能的异常，回调函数没有其他参数。 Node.js 不保证拷贝操作的原子性。 如果在打开目标文件用于写入后发生错误，则 Node.js 将尝试删除目标文件。flags 是一个可选的整数，指定拷贝操作的行为。 可以创建由两个或更多个值按位或组成的掩码（比如 fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE）。 fs.constants.COPYFILE_EXCL - 如果 dest 已存在，则拷贝操作将失败。 fs.constants.COPYFILE_FICLONE - 拷贝操作将尝试创建写时拷贝（copy-on-write）链接。如果平台不支持写时拷贝，则使用后备的拷贝机制。 fs.constants.COPYFILE_FICLONE_FORCE - 拷贝操作将尝试创建写时拷贝链接。如果平台不支持写时拷贝，则拷贝操作将失败。123456const fs = require('fs');// 默认情况下将创建或覆盖目标文件。fs.copyFile('源文件.txt', '目标文件.txt', (err) => {if (err) throw err;console.log('源文件已拷贝到目标文件');}); 如果第三个参数是数字，则它指定 flags: 1234const fs = require('fs');const { COPYFILE_EXCL } = fs.constants;// 通过使用 COPYFILE_EXCL，如果目标文件存在，则操作将失败。fs.copyFile('源文件.txt', '目标文件.txt', COPYFILE_EXCL, callback); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"}]},{"title":"http爬虫和模块化","date":"2019-06-21T12:16:08.207Z","path":"/posts/4a117b12/","text":"http爬虫 和 模块化 http爬虫 12345678910111213141516171819202122232425262728293031323334const https = require(\"https\");const cheerio = require('cheerio');const req = https.get(\"https://www.17k.com/all\", (res) => { // res response 响应( 回馈 ) res.setEncoding('utf8'); // 得到结果的编码 let rawData = ''; res.on('data', (chunk) => { rawData += chunk; }); res.on('end', () => { try { //console.log(rawData) // html string const $ = cheerio.load(rawData) $('.td3 a').each(function(i, ele) { console.log($(this).text()) }) } catch (e) { console.error(e.message); } });}).on('error', (e) => { console.error(`Got error: ${e.message}`);});req.end() http web服务器渲染数据发送前台 1234567891011121314151617181920212223242526272829303132333435363738394041424344const https = require(\"https\");const http = require(\"http\");const cheerio = require('cheerio');const port = 8000;const host = 'localhost';const server = http.createServer(function(request, response) { response.writeHead(200, { 'Content-Type': 'text/html;charset=utf8' // 'Content-Type': 'text/html' }) const req = https.get(\"https://www.17k.com/all\", (res) => { // res response 响应( 回馈 ) res.setEncoding('utf8'); // 得到结果的编码 let rawData = ''; res.on('data', (chunk) => { rawData += chunk; }); res.on('end', () => { try { //console.log(rawData) // html string const $ = cheerio.load(rawData) $('.td3 a').each(function(i, ele) { response.write(`${ $(this).text() }`) }) response.end(); } catch (e) { console.error(e.message); } }); }).on('error', (e) => { console.error(`Got error: ${e.message}`); }); req.end()}).listen(port, host, function() { console.log(`http://${host}:${port}`)}) 中文乱码 123456789101112131415161718192021222324252627282930/* 服务器： 可以运行在服务端一个网站（站点） 种类： 1. web服务器（ 静态服务器 ） ，可以运行在浏览器中的服务器 2. api服务器 （ 后端接口 ） 后端语言暴露一个数据接口，用于前端数据请求（ ajax fetch ） Node.js中原生创建web服务器 http模块 createServer( callback ) 创建服务器 callback中接收三个参数 request response listen(port,host,callback) 监听服务器（ 反馈服务器状态 ） port 端口 host 域名 Node.js中中文乱码 1. 设置请求头 response.writeHead( 200, { 'Content-Type': 'text/html;charset=UTF8' // 小写也可以 utf8 }) 2. 发送一个meta标签 response.write('') 3. toString() 在当前应用场景中还不行 二进制有效 将二进制 --- 》 string 名词： chunk 分片 我们刚才发送了一个html给前台，那么这种渲染数据的形式我们称之为： ‘后端渲染’，也称之为：‘服务端渲染’，英文叫法： ‘ssr’*/ 2. 前端模块化 问题： 为什么前端要使用模块化？ 模块化： 是具有特定功能的一个对象（ 广义理解 ） 模块定义的流程： 1.定义模块（对象） 2.导出模块 3.引用模块 好处： 可以存储多个独立的功能块 复用性高 种类 AMD（ require.js） CMD ( sea.js ) Common.js AMD定义一个模块 define 1234567891011121314151617// AMD/* 目录 admDir a.js index.js*/// AMD定义 a.js define ({ a: 1, b: 2, add: function(){} })// AMD引用 index.js require([./a.js],function( moduleA ){ //moduleA指的就是定义来的对象 }) CMD定义模块 define 1234567891011121314151617//CMD/* 目录结构 b.js index.js*/// 模块定义 b.js define(function(require, exports, module) { // 模块代码 });//模块引用 index.js require('./b.js',function( moduleB ){ //moduleB就是b模块中导出的内容 }) Common.js Node.js使用了Common.js的规范 易错的理解： common.js是属于node的 × node属于common.js ×1234567891011121314//common.js/* 目录结构： name.js index.js*///模块的定义 name.js const nameObj = { name: 'Gabriel Yan ' }//模块的导出 name.js module.exports = nameObj//模块的引用 const nameObj = require('./name.js') Node.js中Common.js规范的使用有三种类型： 内置模块（ 内置模块指的是挂载在Node.js全局对象身上的api ） 自定义模块 模块的定义 123456//举例const student = { id: 1, name: 'Gabriel Yan'}const fn = function(){} 模块的导出 123456// 第一种导出module.exports = student // 安全性不高 默认导出一个//第二种导出module.exports = { //批量导出，按需引用 student,fn} 模块的引用 1234// 这种引用对应第一种导出const student = require('./xxx.js')// 这种引用对应第二种导出const { student , fn } = require( './xxx.js ' ) 注意： 在自定义模块引用时，require一定要写好路径 第三方模块 12345678910111. 别人已经封装好的模块2. 这个模块具备一些特定的功能3. 这些模块存放在 www.npmjs.com 这个网站中这些模块的文档也记录在内格式： var/let/const 变量名 = require( 模块名称 ) 总结： 第一步，使用npm/cnpm 安装 第二部，在文件中引入 第三部，在www.npmjs.com这个网站中找到这个模块的文档，根据文档来使用 思考： 我们是不是能将自己封装的自定义模块变成第三方模块？ 分析： 第三方模块具备的特性： 有一定的功能2. 存储在: http://www.npmjs.com 中 解决： 自定义模块的上传（ http://www.npmjs.com ） 创建package.json文件 1$ npm init -y 在http://www.npmjs.com 这个网站注册一个账号 注意：第一次登陆会发送一个邮件给你的邮箱（ 这个发送是手动的 ），然后大家登陆邮箱激活 检查你的电脑的源是不是npm源 1$ nrm ls 如果是，就不会理会 如果不是，那么切换到npm源 命令行登录npmjs仓库 1$ npm adduser 创建模块并导出模块 查看你的包名称是否已经被使用 发布包 1$ npm publish 犯错点： 邮箱没有激活 （ 最多的 ） npm源没有切换 整个电脑的npm就不能使用 -D === –save-dev 1234//举例cnpm i jquery -D === cnpm i jquery --save-dev // 开发环境下使用cnpm i jquery -S === cnpm i jquery --save // 生产环境下使用 ​ Node.js跨域 跨域； 前端跨域 jsonp 反向代理（ 创建一个虚拟后端服务器，让这个后端服务器帮助我们请求数据） 后端跨域 node php java 设置请求头 使用第三方的中间件（ cors ） 中间件： 就是具有一定功能的一个函数 前端模块化1. amd AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。 首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。 1234567891011121314151617/** 网页中引入require.js及main.js **//** main.js 入口文件/主模块 **/// 首先用config()指定各模块路径和引用名require.config({ baseUrl: \"js/lib\", paths: { \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", }});// 执行基本操作require([\"jquery\",\"underscore\"],function($,_){ // some code here});复制代码 引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。 12345678910111213141516171819202122232425262728// 定义math.js模块define(function () { var basicNum = 0; var add = function (x, y) { return x + y; }; return { add: add, basicNum :basicNum };});// 定义一个依赖underscore.js的模块define(['underscore'],function(_){ var classify = function(list){ _.countBy(list,function(num){ return num > 30 ? 'old' : 'young'; }) }; return { classify :classify };})// 引用模块，将模块放在[]内require(['jquery', 'math'],function($, math){ var sum = math.add(10,20); $(\"#sum\").html(sum);}); ​ 2. cmd- require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码： 1234567define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.foo() } }); CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。 123456789101112131415161718192021222324252627282930313233/** AMD写法 **/define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() } });/** CMD写法 **/define(function(require, exports, module) { var a = require('./a'); //在需要时申明 a.doSomething(); if (false) { var b = require('./b'); b.doSomething(); }});/** sea.js **/// 定义模块 math.jsdefine(function(require, exports, module) { var $ = require('jquery.js'); var add = function(a,b){ return a+b; } exports.add = add;});// 加载模块seajs.use(['math.js'], function(math){ var sum = math.add(1+2);});3.ES6 Module- ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。 123456789101112/** 定义模块 math.js **/var basicNum = 0;var add = function (a, b) { return a + b;};export { basicNum, add };/** 引用模块 **/import { basicNum, add } from './math';function test(ele) { ele.textContent = add(99 + basicNum);}​ ​ 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。 12345678/** export default **///定义输出export default { basicNum, add };//引入import math from './math';function test(ele) { ele.textContent = math.add(99 + math.basicNum);} ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。 4.ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"}]},{"title":"MongoDB","date":"2019-06-21T12:10:16.785Z","path":"/posts/0/","text":"MongoDBMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 常用命令1234567891011121314151617181920212223242526272829303132333435363738show dbs 查看数据库use dbname 创建数据库 如果不存在创建数据库，否则切换到数据库show collections 显示数据库集合1.添加数据 db.web.save({\"name\": \"meiejuna\"}) 创建了名称为 web 的名称，名 db.web.insert({\"name\": \"meijuna\"}) 插入相同的数据，sava 覆盖，insert 报错 2.删除数据 db.students.remove( {} ) 删除 students 集合下的所有数据 db.students.remove({\"name\": \"meijuna\" }) 删除 students 集合为 name 为 meijuna 的数据 db.students.drop() or db.runCommand({\"\"})删除 students 集合 db.runCommand( { dropDaatabase: 1 } ) 删除当前数据库 3.修改数据db.students.updata({\"name\": \"meijuna\"},set:{\"sex\":\"women\"}) 单行修改db.students.updata({\"name\": \"meijuna\"},{$set:{\"sex\":\"women\"}}, true, true) 多行修改 //{查找条件} , { 修改内容 } 匹配所有条件数据 修改所有匹配项4.查找数据 db.students.find() 查找 students 集合中的 所有 数据 db.students.findONe() 查找 students 集合中的 第一条 数据 db.students.find().pretty() 可视化查询 5.排序 db.students.find().sort({\"age\": 1}) 1 升 -1 降序6.截取db.students.find().skip(2) 下标为 2 开始截取db.students.find().limit(2) 截取 2 条数据7.筛选显示db.students.find({age:20},{_id:0,age:1,name:1}) 0,筛选的结果不显示，1筛选结果显示 SQL简介 关系型数据库 以行和列的形式存储数据，以便于用户理解。这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。 关系型数据库有：mySql oracle SqlServer Access *db2 * 等 NoSQL简介 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 非关系型数据库: MongoDB，Redis，HBase，*CouchDB * 等 非关系型数据库与关系型数据库区别关系型数据库的优势：1. 复杂查询 可以用SQL语句方便的在多个表之间做非常复杂的数据查询。 2. 事务支持 使得对于安全性能很高的数据访问要求得以实现。 非关系型数据库的优势：1. 性能 NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2. 可扩展性 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 MongoDB优点它的特点是高性能、易部署、易使用，存储数据非常方便。 主要功能特性有： 面向集合存储，易存储对象类型的数据。 模式自由。 支持动态查询。 支持完全索引，包含内部对象。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象（如视频等）。 自动处理碎片，以支持云计算层次的扩展性 支持RUBY，PYTHON，JAVA，C++，PHP等多种语言。 文件存储格式为BSON（一种JSON的扩展） #### BSON 存储格式BSON是一种类似json的二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，**如Date和BinData类型。 BSON有三个特点：轻量性、可遍历性、高效性。 非关系型数据库文件存储格式为 BSON（一种JSON的扩展）。 MongoDB下载与安装1. MongoDB下载：https://www.mongodb.com/download-center#community 2. 设置环境变量在环境变量窗口中一般有两个变量，一个是你当前所使用的用户独有的环境变量，另一个是所有用户都可以访问的系统变量。其实如果在你的电脑上你只使用一个用户的话，那么不管你修改的用户的环境变量还是系统变量，效果都是一样的。为了以防未来会新建其他用户，那么我建议你修改系统变量而不是某个用户独有的环境变量。 3. 测试连接 管理员身份运行 cmd 输入 mongo 启动 mongdb 服务 net start mongdb 关闭 mongdb 服务 net stop MongoDB 4. 安装可视化工具(Robo 3T)https://robomongo.org/download node 使用 MongoDB 连接 MongoDB 123456789101112131415//1. 下载 mongoose cnpm i mongoose -D //2. 引入 mongoose const mongoose = require( 'mongoose');//3. 连接 mongoose // 连接本地mongodb ，本机的ip 127.0.0.1，端口：27017 数据库：studentmongoose.connect(\"mongodb://127.0.0.1:27017/student\",function(err){ if(!err){ console.log(\"connected to Mongodb\"); //连接成功 }else{ throw err;//如果连接失败，则抛出异常 }}); 存储数据 Schema不仅定义了文档结构和使用性能，还可以有扩展插件、实例方法、静态方法、复合索引、文档生命周期钩子。 12345Schema ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力Model ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对Entity ： 由Model创建的实体，他的操作也会影响数据库 存储数据步骤：定义Schema (骨架) > 创建model（模型）> Entity实例化方法。 1234567891011121314151617181920212223242526272829const mongoose = require( 'mongoose');const Schema = mongoose.Schema;mongoose.connect( 'mongodb://127.0.0.1:27017/meijuna',(error) => { if ( error ) { throw error } else { console.log( 'database is connected~') }})const userSchema = new Schema({ //定义数据模型 username: String, password: String})//通过模式studentSchema 创建一个模型studentModel var studentModel = mongoose.model(\"students\",studentSchema );var instance1 = new studentModel (); instance1.name=\"tangyan\";instance1.age=\"18\";instance1.save(function(err){ //通过save方法保存 if (err) { console.log('保存失败'); return; } }); 查询数据 12345// 查userModel.find({}, ( error, result ) => { if ( error ) throw error console.log ( result )}) 修改数据 123456789101112131415userModel.find({ username: 'aaa'}, ( error, result) =>{ if (error) throw error const _id = result[0]._id userModel.findById(_id, ( error, doc ) => { // 修改 if (error ) throw error console.log( doc ); doc.username = \"meijuna\"; doc.save ( (error) => { throw error console.log(\"数据修改成功\") }) })}) 删除数据 1234567891011121314userModel.find({ username: 'aaa'}, ( error, result) =>{ if (error) throw error const _id = result[0]._id userModel.findById(_id, ( error, doc ) => { // 删除 if (error ) throw error doc.remove( (error) => { if (error) throw error console.log('数据删除成功！') }) })}) 注册 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const mongoose = require('mongoose');const Schema = mongoose.Schema;mongoose.connect('mongodb://127.0.0.1:27017/meijuna', (error) => { if (error) { throw error } else { console.log('database is connected !!!') }})const userSchema = new Schema({ //定义数据模型 username: String, password: String})const userModel = mongoose.model('users', userSchema) //模型创建const user = new userModel(); //创建实体router.get('/', (req, res, next) => { const { username, password } = req.query; console.log(username,password); userModel.find({}, (error, result) => { var flag = result.some((item) => { return item.username === username }) if (flag) { //用户名存在 res.render('register', { data: JSON.stringify({ ret: true, //身份验证 权限验证 status: 2 //0 表示失败 1：成功 2： }) }) } else { user.username = username; user.password = password; user.save(); res.render('register', { data: JSON.stringify({ ret : true, status: 1 }) }) } })}) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据库","slug":"数据库","permalink":"https://yhk15978.github.io/tags/数据库/"}]},{"title":"express Node 核心框架","date":"2019-06-21T12:02:11.085Z","path":"/posts/4a17b112/","text":"express Node 核心框架express是一个功能极简, 完全是由路由和中间件构成的一个web开发框架,是非侵入式的框架 1. 为什么要使用 express ?1234567- express 是 Node 的核心框架- express 可以帮助我们快速构建 web 服务器 / api 服务器- express 提供了一个快速生成工具 express-generator - 快速生成工具： 帮助我们快速创建一个项目的工具 2. 安装方式1. 全局安装123$ npm i express-generator -g or $ yarn add express-generator -g 2. npx 安装12345(如果npm版本在 5.2+，那可以不用全局，用npx)$ npx express -e express_demo -e : 指的是我们使用一个叫 ejs 的模板（ejs.js 可以兼容html标签, 可以在标签中写 js ） 3. 项目目录 bin www 启动了一个静态服务器 （ web服务器 ） node_modules 这个项目的依赖包 public 静态资源文件 ( html，css，images) routes 路由文件夹 view xxx.ejs （ 项目模板 ) app.js ( 这个项目的入口文件 ) 4. app.js 文件代码解读123456- app对象的功能 1. 通过app.use来使用具有特定功能的函数 ( 又叫中间件 )- 中间件分类 1. 应用中间件 （ cors ) 2. 路由中间件 app.get( '/' , (req, res, next ) => { } ) 3. 错误处理中间件 function( err, req, res, next ) { } 5. express 创建 api 服务器 （ 创建接口 ） api 服务器是给前端提供接口数据 api 服务器需要使用的给测试工具来测试，不能用浏览器展示 注意： 后端个前端发送的数据类型是 JSON 字符串，前端需要 JSON.parse() 转换成对象 6. restful api 规则restful aip 规则 是一个暴露接口的规则 ，实现是一个接口使用不同的数据请求方式来实现不同的功能总结： 使用restful api 来暴露接口（ 多个数据请求的接口 ） cors中间件的跨域 前端发来的数据， 后端如何接受 get req.query post req.body 7. 数据请求格式1. get 发送数据时，携带的参数时，形式是 Query string Parameters 后端 req.query 获取前端传来的数据 2. post 发送数据时，携带的参数时，形式是 Form Data 前端 req.body 获取前端传来的数据 8. ecj 模板ecj 官网 EJS 是一套简单的模板语言，帮你利用 JavaScript 代码生成 HTML 页面。 12345ejs模板语法: 执行正常js代码 转移输出 非转义输出 后端接口文档 ( 模板来写 )https://www.showdoc.cc/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"}]},{"title":"前端异步流程","date":"2019-06-21T11:20:20.187Z","path":"/posts/4a17b158/","text":"前端异步流程1. 传统的原生异步- 回调函数 - 事件2. 使用异步流程工具（ 别人封装好的东西 ）- es6 Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* Promise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise 所谓Promise ，简单说就是一个容器，里面保存着某个未来才回结束的事件(通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。 Promise 对象的状态不受外界影响 三种状态: pending：进行中 fulfilled :已经成功 rejected 已经失败 状态改变： Promise对象的状态改变，只有两种可能： 从pending变为fulfilled 从pending变为rejected。 这两种情况只要发生，状态就凝固了，不会再变了，这时就称为resolved（已定型）*/ const p1 = new Promise((resolve, reject) => { resolve('任务一') }).then(data => { console.log(data); return data; }) const p3 = new Promise((resolve, reject) => { setTimeout(() => { resolve('任务三') }, 1000) }).then(data => { console.log(data); return data; }) const p2 = new Promise((resolve, reject) => { setTimeout(() => { resolve('任务二') }, 2000) }).then(data => { console.log(data) return data }) console.log('主线程任务') //主线程任务 // all race // 如果作为参数的Promise实例自身定义了catch方法，那么它被rejected是并不会触发Promise.all()的catch方法 // Promise.all中都成功返回才执行 Promise.all([p1, p2, p3]).then(data => { //data为p1,p2,p3返回值组成的数组 console.log(data) //[ '任务一', '任务二', '任务三' ] }).catch(e => console.log(e)) // Promise.race中只要有一个成功返回就执行 Promise.race([p1, p2, p3]).then(data => { //data为p1,p2,p3中最先成功的返回值 console.log(data) //任务一 }) // 以上代码执行结果为 // 主线程任务 // 任务一 // 任务一 // 任务三 // 任务二 // [ '任务一', '任务二', '任务三' ] - es6 generator函数123456789101112131415161718192021/*generator函数在function关键字后面加一个* 这样定义的函数就叫做generator函数通过yield关键字来定义任务通过fn().next() 来执行任务value表示yield关键字后任务执行的结果done表示当前定义的所有的任务是否执行完成的一个状态理解：多任务的定义，多任务执行让自己定义的多个任务依次执行，上一个任务如果没有完成，下一个任务就不会开始*/function* fn() {yield '任务一'yield '任务二'return '任务'}const a = fn()console.log(a.next()) // { value: '任务一'，done: false }console.log(a.next()) //{ value: '任务二', done: false }console.log(a.next()) //{ value: '任务', done: true }console.log('主线程任务') //主线程任务 es6( 7 ) async 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*async函数es6提供配合关键字 await使用await 表示，等待，任务一执行结束之后，才会执行任务二async函数返回值为Promise对象*/async function fn() { const result = await '任务一' console.log(result) console.log('任务二')}fn()const fn1 = async() => {const res = await new Promise((res, rej) => { setTimeout(() => { res('任务3') }, 2000) }).then(result => { console.log(result) return result;})let req = await new Promise((res, rej) => { setTimeout(() => { res('任务四') }, 1000) }).then(result => { console.log(result) return result;}) console.log(req) console.log(res)if (false) { return req} else { throw res}//返回值通过then()调用，抛出值通过catch()调用}fn1().then(re => console.log(re)).catch(re => console.log(re))//结果:// 任务一// 任务二// 任务3// 任务四// 任务四// 任务3// 任务3 - node.js中的 nextTick setImmudiate 1234567nextTick()的回调函数执行的优先级要高于setImmediate();process.nextTick()属于idle观察者,setImmediate()属于check观察者.在每一轮循环检查中,idle观察者先于I/O观察者,I/O观察者先于check观察者.在具体实现上,process.nextTick()的回调函数保存在一个数组中,setImmediate()的结果则是保存在链表中.在行为上,process.nextTick()在每轮循环中会将数组中的回调函数全部执行完.而setImmediate()在每轮循环中执行链表中的一个回调函数.nextTick > 回调函数 > setImmediate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*Node.js提供的nextTicksetImmediate*///加入2个nextTick()的回调函数process.nextTick(function(){ console.log(\"nextTick延迟执行A\");});process.nextTick(function(){ console.log(\"nextTick延迟执行B\");setImmediate(function(){ console.log(\"setImmediate延迟执行C\");});process.nextTick(function(){ console.log(\"nextTick延迟执行D\");});});//加入两个setImmediate()回调函数setImmediate(function(){ console.log(\"setImmediate延迟执行E\");process.nextTick(function(){ console.log(\"强势插入F\");});setImmediate(function(){ console.log(\"setImmediate延迟执行G\");});});setImmediate(function(){ console.log(\"setImmediate延迟执行H\");process.nextTick(function(){ console.log(\"强势插入I\");});process.nextTick(function(){ console.log(\"强势插入J\");});setImmediate(function(){ console.log(\"setImmediate延迟执行K\");});});console.log(\"正常执行L\");// 正常执行L// nextTick延迟执行A// nextTick延迟执行B// nextTick延迟执行D// setImmediate延迟执行E// setImmediate延迟执行H// setImmediate延迟执行C// 强势插入F// 强势插入I// 强势插入J// setImmediate延迟执行G// setImmediate延迟执行K - 第三方的 async.js 库 12345678910111213141516171819202122232425262728293031323334353637383940414243/*async.js第三方的库案例：parallelseries功能：1. 可以实现异步2. 串行series和并行parallel*/const async = require( 'async' ) async.series({ one: function ( callback ) { setTimeout( function () { callback( null, 1)},200)},two: function ( callback ) {setTimeout( function () { callback ( null , 2 )},100)}}, function ( error , results ) { console.log( 'series',results )}) console.log( '主线程' )async.parallel({ one: function ( callback ) {setTimeout( function () { callback( null, 1)},200)},two: function ( callback ) { setTimeout( function () { callback ( null , 2 )},100)}}, function ( error , results ) { console.log( 'parallel',results )}) // 主线程// parallel { two: 2, one: 1 }// series { one: 1, two: 2 } 总结： 异步流程的任务是放在异步队列中的，异步队列只有在主线程执行完之后采取执行 参考资料 Promisehttps://blog.csdn.net/MrJavaweb/article/details/79475949 Generatorhttps://www.cnblogs.com/imwtr/p/5913294.html Async-await Node.js 中的nextTick()和setimmediate()https://www.cnblogs.com/5ishare/p/5268273.html async库https://caolan.github.io/async/参考文档Event-loophttp://www.ruanyifeng.com/blog/2014/10/event-loop.html?bsh_bid=983729729史上最易读懂的 Promise/A+ 完全实现https://zhuanlan.zhihu.com/p/21834559 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"}]},{"title":"vue基础语法","date":"2019-06-19T11:59:36.232Z","path":"/posts/4a17b157/","text":"vue基础语法mutache 语法糖123456&lt;div id=\"app\"&gt; &lt;p&gt; {{ this.msg }} &lt;/p&gt; &lt;p&gt; {{ this.$data.msg }} &lt;/p&gt; &lt;p&gt; {{ this._data.msg }} &lt;/p&gt; &lt;p&gt; {{ msg }} &lt;/p&gt;&lt;/div&gt; jsx: javascript + xml可以让我们在dom结构中输写javascript 是 this.msg 简写this.$data.msg -> this.msg -> msg mustache语法糖对数据类型的支持（ js语法的支持 ）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt; number: {{ num }} &lt;/p&gt; &lt;p&gt; string: {{ str }} &lt;/p&gt; &lt;p&gt; boolean: {{ bool }} &lt;/p&gt; &lt;p&gt; null: {{ nul?'1':'2' }} &lt;/p&gt; &lt;p&gt; undefined: {{ und && 1 || 2 }} &lt;/p&gt; &lt;p&gt; object: {{ obj.name }} &lt;/p&gt; &lt;p&gt; array: {{ arr[0] }} &lt;/p&gt; &lt;p&gt; fn: {{ fn() }} &lt;/p&gt; &lt;!-- &lt;p&gt; console.log: {{ console.log( 1 ) }} &lt;/p&gt; &lt;p&gt; alert: {{ alert( 2 ) }} &lt;/p&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; /* 数据类型： 第一种划分： 基础数据类型： number string boolean 复杂数据类型: Object( array function ) 特殊数据类型: null undefined 第二种划分： 初始数据类型: number string boolean null undefined 引用数据类型: object( array function ) 结论： mustache支持我们js的数据类型的 conosle.log 和 alert 在我们mustache语法中是不支持的 */var vm = new Vue({ el: '#app', data: { num: 100, str: 'hello Vue.js', bool: true, nul: null, und: undefined, obj: { name: 'yhk' }, arr: [1,2,3,4], fn: function () { alert( 2 ) return '这是一个函数' } }})&lt;/script&gt; mustache 绑定 dom的属性123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;p v-html = \"h\"&gt;&lt;/p&gt; &lt;p v-text = \"msg\"&gt;&lt;/p&gt; &lt;p v-text = \" flag && 1 || 2 \" &gt; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; /* 案例： v-html 分析： 发现dom元素直接有了一个内容 这种属性绑定就是为了操作dom 结论： 这种属性绑定的形式就是为了操作dom，我们给这种属性起了一个好听的名字 Vue 1.0 叫它 属性指令（ 借鉴Angular来的 ） Vue 2.0 统称为 ‘指令’ 指令是用一个 v-xxx 表示 指令是用来操作dom Vue中不允许直接操作dom!!! mustache语法 --- 属性写法 的属性值是直接写数据的，不需要使用 {{ }} */var vm = new Vue({ el: '#app', data: { msg: 'hello Vue.js', h: '&lt;h3&gt; hello Vue.js &lt;/h3&gt;', flag: true } })&lt;/script&gt; 问题： 我们说vue是 MVVM 框架， 那么谁是 M 谁是 V 谁是 VM 1234567891011121314151617&lt;!-- V --&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script&gt; /* M： Model 数据 V： View 视图 VM: ViewModel 视图模型（ new Vue() ） */ var vm = new Vue({ el: '#app',//给跟实例一个模板（ 挂载 ） data: { //M } })&lt;/script&gt; 指令： ( 是绑定在dom属性上 )v-html:可以解析标签型数据( 可以将一个数据展示在一个dom的内容中（ 相当于使用了 innerHTML ）) v-text：可以将一个数据展示在一个dom的内容中（ 相当于使用了 innerHTML ）条件渲染的指令 v-show可以控制一个dom的显示隐藏（ 这个指令操作的是dom的display属性 ） v-if可以控制一个dom的存在与否（ 创建 和 销毁 ） v-elsev-else-if123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;h3&gt; v-show &lt;/h3&gt; &lt;p v-show = \"showFlag\"&gt; v-show指令 &lt;/p&gt; &lt;hr&gt; &lt;h3&gt; v-if - 单路分支 &lt;/h3&gt; &lt;p v-if = \"ifFlag\"&gt; v-if - 指令的单路分支 &lt;/p&gt; &lt;h3&gt; v-if - 双路分支 &lt;/h3&gt; &lt;p v-if = \"ifFlag\"&gt; 双路分支 成立 &lt;/p&gt; &lt;p v-else&gt; 双路分支不成立 &lt;/p&gt; &lt;h3&gt; v-if - 多路分支 &lt;/h3&gt; &lt;p v-if = \" type === 'A'\"&gt; A &lt;/p&gt; &lt;p v-else-if = \" type === 'B'\"&gt; B &lt;/p&gt; &lt;p v-else&gt; C &lt;/p&gt; &lt;/div&gt;&lt;script&gt;var vm = new Vue({ el: '#app',//给跟实例一个模板（ 挂载 ） data: { showFlag: true, ifFlag: false, type: 'A' }})&lt;/script&gt; 实用题 v-if vs v-show 区别 实用： 项目中 如何选择这两个使用 v-if 操作的是dom元素（ 组件 ） 的创建或是销毁 v-show 操作的是dom元素的display属性 v-if可以有多种使用形式： 单路分支， 多路分支， 双路分支 v-show 只能写一个单路形式一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-for 数组 v-for = “ (item,index) in arr “ item是arr中每一个元素 对象 v-for = “(item,key,index) in obj “ item是obj的属性值 json类型数据 嵌套类型数据 key:给没一个循环的列表添加一个唯一的标识使用指令 v-bind 来绑定 key如果有id，那么我们就使用id，如果没有，我们才会选择indexv-bind: 单项数据绑定： 将一个数据绑定在一个dom的属性上简写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;div id=\"app\"&gt; &lt;h3&gt; 数组 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \" (item,index) in arr \" v-bind:key = \"index\"&gt; &lt;p&gt; item :{{ item }} -- index: {{ index }}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; 对象 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \"(item,key,index) in obj\" v-bind:key = \"index\"&gt; &lt;p&gt; value: {{ item }} -- key: {{ key }} -- {{ index }} &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; json &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \"(item,index) of json\" v-bind:key = \" item.id \"&gt; &lt;p&gt; id: {{ item.id }} &lt;/p&gt; &lt;p&gt; task: {{ item.task }} &lt;/p&gt; &lt;p&gt; {{ index }} &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; 嵌套 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \" item in lists \" :key = \"item.id\"&gt; &lt;p&gt; id: {{ item.id }} &lt;/p&gt; &lt;ul&gt; &lt;li v-for = \"todo in item.todos\"&gt; todos中的数据 -- {{ todo }} &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { arr: [1,2,3,4], obj: { id: 1, name: '骏哥', sex: 'man', age: 18 }, json: [ { id: 1, task: '敲代码1' }, { id: 2, task: '敲代码2' } ], lists: [ { id: 1, todos: { id: 1, name: '连城' } }, { id: 2, todos: { id: 2, name: '文武' } } ] } })&lt;/script&gt; vue中如何给dom添加类名 直接在dom上绑定类名 vue中类名绑定 - 对象形式目的： dom身上属性class 要和 数据绑定解决：v-bind数据中key，我们起的和绑定的对象中的key一样，但是你得知道这两个东西不一样&lt;p :class = \"{ size,bg_color }\"&gt;&lt;/p&gt;size是自定义的属性， 它的属性值是undefined， 相当于是false&lt;p :class = \"{ size: true, bg_color: true }\"&gt;&lt;/p&gt;size也是自定义属性，他的属性是true,那么就会加上去&lt;p :class = \"{ [s]: true, [bg_color]: true }\"&gt;&lt;/p&gt;格式： v-bind:class = \"{ 属性： boolean }\"格式： v-bind:class = \"{ [data]： boolean }\" vue中类名绑定的形式 - 数组的形式 【 推荐 】格式： v-bind:class = \"[ 数据 ]\" 类名绑定不会覆盖原先的类名 为什么要绑定类名指令是用来操作dom目的： 为了将来通过数据来操作类名，类名操作dom12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; .size{ width: 100px; height: 100px; } .bg_color{ background: red; }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;h3&gt; v-class &lt;/h3&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加第一种 &lt;/h3&gt; &lt;p class=\"size bg_color\"&gt;&lt;/p&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加第二种 - 对象的形式&lt;/h3&gt; &lt;p :class = \"{ size: true,bg_color: false }\"&gt;&lt;/p&gt; &lt;p :class = \"{ size: true, bg_color: true }\"&gt;&lt;/p&gt; &lt;p :class = \"{ [s]: true, [bg_color]: true }\"&gt;&lt;/p&gt; &lt;p :class = \"{ [s]: 5&gt;3?true: false, [bg_color]: true }\"&gt;&lt;/p&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加的第三种形式 - 数组形式（ 推荐 ）&lt;/h3&gt; &lt;p :class = \"['size','bg_color']\"&gt;&lt;/p&gt; &lt;p :class = \"[ s, bg_color ]\"&gt;&lt;/p&gt; &lt;p :class = \"[ flag? s:'box', bg_color]\"&gt;&lt;/p&gt; &lt;p :class = \"[ flag? s:'box', bg_color]\" class = \"yyb\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data: { msg: 'hello Vue.js', s: 'size', bg_color: 'bg_color', flag: true } }); var a = { name: 'yhk' } var b = { name: 'mjn' }&lt;/script&gt; 样式的绑定：v-bind:style = “” 对象的形式 数组的形式12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;h3&gt; style &lt;/h3&gt; &lt;hr&gt; &lt;h3&gt; style - 对象形式 &lt;/h3&gt; &lt;p :style = \"{ width: size.width,height: size.height,background: 'red'}\"&gt;&lt;/p&gt; &lt;h3&gt; style - 数组的形式 &lt;/h3&gt; &lt;p :style = \"[ { width: '100px',background: 'blue'},{ height: '100px' } ]\"&gt; &lt;/p&gt; &lt;p :style = \"[ size,bg ]\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { size: { width: '100px', height: '100px' }, bg: { background: 'purple' } } })&lt;/script&gt; 事件问题： javascript事件添加有几种形式 事件绑定dom.onclick = function () {}dom: 事件源on: 绑定事件的形式click: 事件类型function（）{} 事件处理函数 事件监听 ：addeventListener 直接在标签中绑定事件&lt;div onclick = \"事件名称\"&gt;&lt;/div&gt;vue采用了第三种，也是通过属性的形式绑定在dom身上&lt;div v-on:click = \"事件名称\"&gt;&lt;/div&gt;简写：&lt;button @click = \"helloHandler\"&gt; 点击 &lt;/button&gt;v-on使用事件源事件绑定形式事件类型事件处理程序v-on:eventType = “ handlerName “简写 v-on: — > @ 问题： 函数调用有哪些方法？直接调用 ()事件事件对象也可以正常使用在事件处理程序中， 写e就可以了问题： 如果事件处理程序中有三个参数，第三个参数才是事件对象e,如何实现分析： 我们发现事件处理程序中的第三个参数 e 不在是事件对象了，而是一个undefined解决： 在函数执行时，传入一个实际参数 $event 来代表事件对象 问题： 如果我们通过 length = 0 , 来清空一个数组，那么vue检测不到这个变动解决方法： 使用splice问题： 我们直接修改一个数组下的一个数据时，发现下标不能检测变动了解决方法： 使用 Vue.set / this.$set 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;div id=\"app\"&gt; &lt;button @click = \"add\"&gt; + &lt;/button&gt; &lt;button @click = \"remove\"&gt; - &lt;/button&gt; &lt;button @click = \"indexHandler\"&gt; 修改第二条数据 &lt;/button&gt; &lt;ul&gt; &lt;li v-for =\" item in lists \" :key = \"item.id\"&gt; {{ item.task }} &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;button @click = \"arrChange\"&gt; 修改第二条数据 &lt;/button&gt; &lt;ul&gt; &lt;li v-for = \" (item,index ) in arr \" :key = \"index\"&gt; {{ item }} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;/*业务： 点击这个按钮，添加一条新的数据放在列表数据中*/new Vue({ el: '#app', data: { arr: [1,2,3], lists: [ { id: 1, task: '锻炼1' }, { id: 2, task: '敲代码' } ] }, methods: { add () { // console.log( this ) this.lists.push({ id: this.lists.length + 1, task: '打篮球' }) }, remove () { this.lists.pop() }, indexHandler () { //将列表中的第二个数据中的task任务修改为 撸猫 this.lists[1] = { id: 2, task: '骏哥' } // 将整个列表清空 // this.lists.length = 0 // this.lists.splice( 0 ) }, arrChange () { // this.arr[ 1 ] = '骏哥' 不可以检测到的 // this.$set( this.arr,'1','骏哥' ) Vue.set( this.arr,'1','骏哥') } } })&lt;/script&gt; v-model双向数据绑定默认绑定value值v-model应用于表单元素 1234567891011121314&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model = \"msg\"&gt; &lt;p&gt; {{ msg }} &lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: 'hello Vue.js' } })&lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"}]}]