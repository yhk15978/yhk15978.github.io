[{"title":"npm scripts  npm脚本","date":"2019-06-21T12:38:25.690Z","path":"/posts/4a17b235/","text":"转载自：阮一峰http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html 一、什么是 npm 脚本？npm 允许在package.json文件里面，使用scripts字段定义脚本命令。 12345{// ...\"scripts\": {\"build\": \"node build.js\"}} 上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。 命令行下使用npm run命令，就可以执行这段脚本。 123$ npm run build# 等同于执行$ node build.js 这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多。 123项目的相关脚本，可以集中在一个地方。不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。可以利用 npm 提供的很多辅助功能。 查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。 1$ npm run 二、原理npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。 比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。 这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有Mocha，只要直接写mocha test就可以了。 1\"test\": \"mocha test\" 而不用写成下面这样。 1\"test\": \"./node_modules/.bin/mocha test\" 由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。 三、通配符由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。 12\"lint\": \"jshint *.js\"\"lint\": \"jshint **/*.js\" 上面代码中，*表示任意文件名，**表示任意一层子目录。如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。 1\"test\": \"tap test/\\*.js\" 四、传参向 npm 脚本传入参数，要使用--标明 1\"lint\": \"jshint **.js\" 向上面的npm run lint命令传入参数，必须写成下面这样。 1$ npm run lint -- --reporter checkstyle > checkstyle.xml 也可以在package.json里面再封装一个命令。 12\"lint\": \"jshint **.js\",\"lint:checkstyle\": \"npm run lint -- --reporter checkstyle > checkstyle.xml\" 五、执行顺序如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。如果是并行执行（即同时的平行执行），可以使用&符号。 1$ npm run script1.js & npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号。 1$ npm run script1.js && npm run script2.js 这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。 六、默认值一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。 12\"start\":\"node sever.js\",\"install\":\"node-gyp rebuild\" 上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。 七、钩子npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。 123\"prebuild\": \"echo I run before the build script\",\"build\": \"cross-env NODE_ENV=production webpack\",\"postbuild\": \"echo I run after the build script\" 用户执行npm run build的时候，会自动按照下面的顺序执行。 1npm run prebuild && npm run build && npm run postbuild 因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。 123\"clean\": \"rimraf ./dist && mkdir dist\",\"prebuild\": \"npm run clean\",\"build\": \"cross-env NODE_ENV=production webpack\" npm 默认提供下面这些钩子 prepublish，postpublish preinstall，postinstallpreuninstall， postuninstallpreversion，postversionpretest posttestprestop，poststopprestart， poststartprerestart，postrestart 自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。 12345678910const TARGET = process.env.npm_lifecycle_event;if (TARGET === 'test') { console.log(`Running the test task!`);}if (TARGET === 'pretest') { console.log(`Running the pretest task!`);}if (TARGET === 'posttest') { console.log(`Running the posttest task!`);} 注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。 八、简写形式四个常用的 npm 脚本有简写形式。 npm start是npm run start npm stop是npm run stop的简写 npm test是npm run test的简写 npm restart是npm run stop && npm run restart && npm run start的简写 npm start、npm stop和npm restart都比较好理解，而npm restart是一个复合命令，实际上会执行三个脚本命令：stop、restart、start。具体的执行顺序如下。 prerestart prestop stop poststop restart prestart start poststart postrestart 九、变量npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。首先，通过npm_package_前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。 123456{ \"name\": \"foo\", \"version\": \"1.2.5\", \"scripts\": { \"view\": \"node view.js\" }} 那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。 123// view.jsconsole.log(process.env.npm_package_name); // fooconsole.log(process.env.npm_package_version); // 1.2.5 上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是 Bash 脚本，可以用$npm_package_name和$npm_package_version取到这两个值。 npm_package_前缀也支持嵌套的package.json字段。 1234567\"repository\": { \"type\": \"git\", \"url\": \"xxx\" }, scripts: { \"view\": \"echo $npm_package_repository_type\" } 上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。下面是另外一个例子。 12\"scripts\": { \"install\": \"foo.js\"} 上面代码中，npm_package_scripts_install变量的值等于foo.js。 然后，npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。 1\"view\": \"echo $npm_config_tag\", 注意，package.json里面的config对象，可以被环境变量覆盖。 1234{ \"name\" : \"foo\", \"config\" : { \"port\" : \"8080\" }, \"scripts\" : { \"start\" : \"node server.js\" }} 上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。 1$ npm config set foo:port 80 最后，env命令可以列出所有环境变量。 1\"env\": \"env\" 十、常用脚本示例123456789101112131415161718// 删除目录\"clean\": \"rimraf dist/*\",// 本地搭建一个 HTTP 服务\"serve\": \"http-server -p 9090 dist/\",// 打开浏览器\"open:dev\": \"opener http://localhost:9090\",// 实时刷新 \"livereload\": \"live-reload --port 9091 dist/\",// 构建 HTML 文件\"build:html\": \"jade index.jade > dist/index.html\",// 只要 CSS 文件有变动，就重新执行构建\"watch:css\": \"watch 'npm run build:css' assets/styles/\",// 只要 HTML 文件有变动，就重新执行构建\"watch:html\": \"watch 'npm run build:html' assets/html\",// 部署到 Amazon S3\"deploy:prod\": \"s3-cli sync ./dist/ s3://example-com/prod-site/\",// 构建 favicon\"build:favicon\": \"node scripts/favicon.js\", 十一、 npm scripts npm脚本 明白为什么要使用npm脚本 集中存储当前项目的所有脚本命令 npm脚本使用 npm run xxx npm多脚本执行 npm run xxx & npm run xxx npm run xxx && npm run xxx npm脚本可以简写，但是仅限一下几个npm startnpm stopnpm testnpm restart 1234567891011121314151617181920{\"name\": \"scripts\",\"version\": \"1.0.0\",\"description\": \"\",\"main\": \"index.js\",\"scripts\": {\"pretest\": \"echo pretest\",\"test\": \"echo test\",\"posttest\": \"echo posttest\",\"dev\": \"node server.js\",\"build\": \"npm run dev\",\"app\": \"node app.js\",\"yyb\": \"npm run app&npm run dev\",\"junge\": \"npm run app&&npm run dev\",\"env\": \"env\"},\"keywords\": [],\"author\": \"\",\"license\": \"ISC\"} 十一、参考链接* http://www.ruanyifeng.com/blog/2016/10/npm_scripts.htmlby ruanyifeng document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"}]},{"title":"Node.js 常用模块","date":"2019-06-21T12:26:48.145Z","path":"/posts/4a17b109/","text":"Node.js 常用模块URL url.parse(urlString[, parseQueryString[, slashesDenoteHost]]) 将url字符转成url对象 urlString 要解析的 URL 字符串。 parseQueryString 如果设为 true，则返回的 URL 对象的 query 属性会是一个使用 querystring 模块的 parse() 生成的对象。 如果设为 false，则 query 会是一个未解析未解码的字符串。 默认为 false。 slashesDenoteHost 如果设为 true，则 // 之后至下一个 / 之前的字符串会解析作为 host。 例如， //foo/bar 会解析为 {host: 'foo', pathname: '/bar'} 而不是 {pathname: '//foo/bar'}。 默认为 false。 url.format(URL[, options])将url对象转成url字符 URL 一个对象 options auth 如果序列化的URL字符串应该包含用户名和密码为true，否则为false。默认为true。 fragment 如果序列化的URL字符串应该包含分段为true，否则为false。默认为true。 search如果序列化的URL字符串应该包含搜索查询为true，否则为false。默认为true。 unicode true 如果出现在URL字符串主机元素里的Unicode字符应该被直接编码而不是使用Punycode编码为true，默认为false。 3.url.resolve(from, to)url路径的拼接，替换 from 解析时相对的基本 URL。 to要解析的超链接 URL。 例子：1234const url = require('url');url.resolve('/one/two/three', 'four'); // '/one/two/four'url.resolve('http://example.com/', '/one'); // 'http://example.com/one'url.resolve('http://example.com/one', '/two'); // 'http://example.com/two' querystring（查询字符串） querystring.stringify(obj[, sep[, eq[, options]]])解析对象部分转成URLsearch obj 要序列化为 URL 查询字符串的对象。 sep用于在查询字符串中分隔键值对的子字符串。默认值: '&'。 eq 用于在查询字符串中分隔键和值的子字符串。默认值: '='。 options encodeURIComponent 在查询字符串中将 URL 不安全字符转换为百分比编码时使用的函数。默认值: querystring.escape()。 querystring.stringify() 方法通过迭代对象的自身属性从给定的 obj 生成 URL 查询字符串1234querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });// 返回 'foo=bar&baz=qux&baz=quux&corge='querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');// 返回 'foo:bar;baz:qux' 默认情况下，查询字符串中需要百分比编码的字符将编码为 UTF-8。 如果需要其他编码，则需要指定其他 encodeURIComponent 选项： 123// 假设 gbkEncodeURIComponent 函数已存在。querystring.stringify({ w: '中文', foo: 'bar' }, null, null,{ encodeURIComponent: gbkEncodeURIComponent }); querystring.parse(str[, sep[, eq[, options]]]) 解析URLsearch部分转成对象 str 要解析的 URL 查询字符串。 sep 用于在查询字符串中分隔键值对的子字符串。默认值: '&'。 eq用于在查询字符串中分隔键和值的子字符串。默认值: '='。 options decodeURIComponent解码查询字符串中的百分比编码字符时使用的函数。默认值: querystring.unescape()。 maxKeys 指定要解析的键的最大数量。指定 0 可移除键的计数限制。默认值: 1000。 querystring.parse() 方法将 URL 查询字符串 str 解析为键值对的集合。例如，查询字符串 'foo=bar&abc=xyz&abc=123' 被解析为：1234{foo: 'bar',abc: ['xyz', '123']} querystring.parse() 方法返回的对象不是原型继承自 JavaScript Object。 这意味着典型的 Object 方法如 obj.toString()、 obj.hasOwnProperty() 等都没有定义并且不起作用。默认情况下，将假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他字符编码，则需要指定其他 decodeURIComponent 选项： 123// 假设 gbkDecodeURIComponent 函数已存在。querystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null,{ decodeURIComponent: gbkDecodeURIComponent }); querystring.escape(str) 可以将中文转成url百分比编码 strquerystring.escape() 方法以对 URL 查询字符串的特定要求进行了优化的方式对给定的 str 执行 URL 百分比编码。querystring.escape() 方法由 querystring.stringify() 使用，通常不会直接使用。 它的导出主要是为了允许应用程序代码在必要时通过将 querystring.escape 指定给替代函数来提供替换的百分比编码实现。 querystring.unescape(str)可以将url百分比编码解码 strquerystring.unescape() 方法在给定的 str 上执行 URL 百分比编码字符的解码。querystring.unescape() 方法由 querystring.parse() 使用，通常不会直接使用它。 它的导出主要是为了允许应用程序代码在必要时通过将 querystring.unescape 分配给替代函数来提供替换的解码实现。默认情况下， querystring.unescape() 方法将尝试使用 JavaScript 内置的 decodeURIComponent() 方法进行解码。 如果失败，将使用更安全的不会丢失格式错误的 URL 的等价方法。http模块 http.get(options[, callback])http.get(url[,options][, callback]) url string| url options 接受与 http.request() 相同的 options，且 method 始终设置为 GET。从原型继承的属性将被忽略。 callbackFunction 返回:http.ClientRequest由于大多数请求都是没有主体的 GET 请求，因此 Node.js 提供了这个便捷的方法。 这个方法与 http.request() 的唯一区别是它将方法设置为 GET 并自动调用 req.end()。 注意，由于 http.ClientRequest 章节中所述的原因，回调必须注意消费响应数据。callback 调用时只有一个参数，该参数是 http.IncomingMessage 的实例。获取 JSON 的示例：12345678910111213141516171819202122232425262728293031http.get('http://nodejs.cn/index.json', (res) => {const { statusCode } = res;const contentType = res.headers['content-type'];let error;if (statusCode !== 200) {error = new Error('请求失败\\n' +`状态码: ${statusCode}`);} else if (!/^application\\/json/.test(contentType)) {error = new Error('无效的 content-type.\\n' +`期望的是 application/json 但接收到的是 ${contentType}`);}if (error) {console.error(error.message);// 消费响应数据来释放内存。res.resume();return;}res.setEncoding('utf8');let rawData = '';res.on('data', (chunk) => { rawData += chunk; });res.on('end', () => {try {const parsedData = JSON.parse(rawData);console.log(parsedData);} catch (e) {console.error(e.message);}});}).on('error', (e) => {console.error(`出现错误: ${e.message}`);}); http.request(options[, callback]) http.request(url[, options][, callback]) url |url options Object protocol 使用的协议。默认值: 'http:'。 host 请求发送至的服务器的域名或 IP 地址。默认值: 'localhost'。 hostname host 的别名。为了支持 url.parse()，如果同时指定 host 和 hostname，则使用 hostname。 family number当解析 host 或 hostname 时使用的 IP 地址族。有效值为 4 或 6。如果没有指定，则同时使用 IP v4 和 v6。 port number远程服务器的端口。默认值: 80。 localAddress 为网络连接绑定的本地接口。 socketPath Unix 域套接字。如果指定了 host 或 port 之一（它们指定了 TCP 套接字），则不能使用此选项。 method 一个字符串，指定 HTTP 请求的方法。默认值: 'GET'。 path 请求的路径。应包括查询字符串（如果有）。例如 '/index.html?page=12'。当请求的路径包含非法的字符时，则抛出异常。目前只有空格被拒绝，但未来可能会有所变化。默认值: '/'。 headersObject 包含请求头的对象。 auth 基本的身份验证，即 'user:password'，用于计算授权请求头。 agent | 控制 Agent 的行为。可能的值有： undefined (默认): 对此主机和端口使用 http.globalAgent。 Agent 对象: 显式地使用传入的 Agent。 false: 使用新建的具有默认值的 Agent。 createConnection 当 agent 选项未被使用时，用来为请求生成套接字或流的函数。这可用于避免创建自定义的 Agent 类以覆盖默认的 createConnection 函数。详见 agent.createConnection()。任何双工流都是有效的返回值。 timeout: 指定套接字超时的数值，以毫秒为单位。这会在套接字被连接之前设置超时。 setHost : 指定是否自动添加 Host 请求头。默认值: true。 callback 返回: Node.js 为每个服务器维护多个连接以发出 HTTP 请求。 此函数允许显式地发出请求。url 可以是字符串或 URL 对象。 如果 url 是一个字符串，则会自动使用 url.parse() 解析它。 如果它是一个 URL 对象，则会自动转换为普通的 options 对象。如果同时指定了 url 和 options，则对象会被合并，其中 options 属性优先。可选的 callback 参数会作为单次监听器被添加到 'response' 事件。http.request() 返回 http.ClientRequest 类的实例。 ClientRequest 实例是一个可写流。 如果需要使用 POST 请求上传文件，则写入到 ClientRequest 对象。123456789101112131415161718192021222324252627282930const postData = querystring.stringify({'msg': '你好世界'});const options = {hostname: 'nodejs.cn',port: 80,path: '/upload',method: 'POST',headers: {'Content-Type': 'application/x-www-form-urlencoded','Content-Length': Buffer.byteLength(postData)}};const req = http.request(options, (res) => {console.log(`状态码: ${res.statusCode}`);console.log(`响应头: ${JSON.stringify(res.headers)}`);res.setEncoding('utf8');res.on('data', (chunk) => {console.log(`响应主体: ${chunk}`);});res.on('end', () => {console.log('响应中已无数据');});});req.on('error', (e) => {console.error(`请求遇到问题: ${e.message}`);});// 将数据写入请求主体。req.write(postData);req.end(); 注意，在示例中调用了 req.end()。 使用 http.request() 时，必须始终调用 req.end() 来表示请求的结束，即使没有数据被写入请求主体。如果在请求期间遇到任何错误（DNS 解析错误、TCP 层的错误、或实际的 HTTP 解析错误），则会在返回的请求对象上触发 'error' 事件。 与所有 'error' 事件一样，如果没有注册监听器，则会抛出错误。以下是需要注意的一些特殊的请求头。 发送 'Connection: keep-alive' 会通知 Node.js 与服务器的连接应该持续到下一个请求。 发送 'Content-Length' 请求头会禁用默认的分块编码。 发送 'Expect' 请求头会立即发送请求头。通常情况下，当发送 'Expect: 100-continue' 时，应设置超时时间和 'continue' 事件的监听器。详见 RFC2616 的第 8.2.3 节。 发送授权请求头会使用 auth 选项覆盖以计算基本的身份验证。使用 URL 作为 options 的示例：1234const options = new URL('http://abc:xyz@nodejs.cn');const req = http.request(options, (res) => {// ...}); 在成功的请求中，会按以下顺序触发以下事件： 'socket' 事件 'response' 事件 res 对象上任意次数的 'data' 事件（如果响应主体为空，则根本不会触发 'data' 事件，例如在大多数重定向中） res 对象上的 'end' 事件 'close' 事件如果出现连接错误，则触发以下事件： 'socket' 事件 'error' 事件 'close' 事件如果在连接成功之前调用 req.abort()，则按以下顺序触发以下事件： 'socket' 事件 (在这里调用 req.abort()) 'abort' 事件 'error' 事件并带上错误信息 'Error: socket hang up' 和错误码 'ECONNRESET' 'close' 事件如果在响应被接收之后调用 req.abort()，则按以下顺序触发以下事件： 'socket' 事件 'response' 事件 res 对象上任意次数的 'data' 事件 (在这里调用 req.abort()) 'abort' 事件 res 对象上的 'aborted' 事件 'close' 事件 res 对象上的 'end' 事件 res 对象上的 'close' 事件注意，设置 timeout 选项或使用 setTimeout() 函数不会中止请求或执行除添加 'timeout' 事件之外的任何操作。 http.createServer([options][, requestlistener]) 创建服务 options IncomingMessage 指定要使用的 IncomingMessage 类。用于扩展原始的 IncomingMessage。默认值:IncomingMessage。 ServerResponse 指定要使用的 ServerResponse 类。用于扩展原始 ServerResponse。默认值: ServerResponse。 requestListener 返回: 返回新建的 http.Server 实例。requestListener 是一个自动添加到 'request' 事件的函数。// server.listen 是开启监听// 第一个参数是port// 第二个参数可选 是回调server.listen(port, () => {console.log(server is running on ${port});}); 阿萨fs（文件系统） fs.readFile(path[, options], callback) 读取文件 path文件名或文件描述符。 options encoding 默认值: null。 flag 参阅支持的文件系统标志。默认值: 'r'。 callback err data异步地读取文件的全部内容。1234fs.readFile('/etc/passwd', (err, data) => {if (err) throw err;console.log(data);}); 回调会传入两个参数 (err, data)，其中 data 是文件的内容。如果没有指定 encoding，则返回原始的 buffer。如果 options 是字符串，则它指定字符编码： 1fs.readFile('/etc/passwd', 'utf8', callback); 当 path 是目录时， fs.readFile() 与 fs.readFileSync() 的行为是特定于平台的。 在 macOS、Linux 和 Windows 上，将返回错误。 在 FreeBSD 上，将返回目录内容的表示。 12345678// 在 macOS、Linux 和 Windows 上：fs.readFile('', (err, data) => {// => [Error: EISDIR: illegal operation on a directory, read ]});// 在 FreeBSD 上：fs.readFile('', (err, data) => {// => null, }); fs.readFile() 函数会缓冲整个文件。 为了最小化内存成本，尽可能通过 fs.createReadStream() 进行流式传输。 fs.writeFile(file, data[, options], callback) 写入文件 file | | | 文件名或文件描述符。 data | | | options | encoding | 默认值: 'utf8'。 mode 默认值: 0o666。 flag 参阅支持的文件系统标志。默认值: 'w'。 callback err 异步地将数据写入到一个文件，如果文件已存在则覆盖该文件。 data 可以是字符串或 buffer。如果 data 是一个 buffer，则 encoding 选项会被忽略。12345const data = new Uint8Array(Buffer.from('Node.js中文网'));fs.writeFile('文件.txt', data, (err) => {if (err) throw err;console.log('文件已被保存');}); 如果 options 是一个字符串，则它指定字符编码： 1fs.writeFile('文件.txt', 'Node.js中文网', 'utf8', callback); 在同一个文件上多次使用 fs.writeFile() 且不等待回调是不安全的。 对于这种情况，建议使用 fs.createWriteStream()。 文件描述符中英对照提交修改 任何指定的文件描述符都必须支持写入。 如果将文件描述符指定为 file，则不会自动关闭它。 写入将从文件的开头开始。例如，如果文件已经有内容 'Hello World‘ 并且新写入的内容是 'Aloha'，则该文件的内容将是 'Aloha World' 而不仅仅是 'Aloha'。 fs.rename(oldPath, newPath, callback) oldPath newPath callback err异步地将 oldPath 上的文件重命名为 newPath 提供的路径名。 如果 newPath 已存在，则覆盖它。 除了可能的异常，完成回调没有其他参数。也可参阅 rename(2)。1234fs.rename('旧文件.txt', '新文件.txt', (err) => {if (err) throw err;console.log('重命名完成');}); fs.readdir(path[, options], callback) path options encoding默认值: 'utf8'。 withFileTypes) 默认值: false。 callback err files异步的 readdir(3)。 读取目录的内容。 回调有两个参数 (err, files)，其中 files 是目录中的文件名的数组（不包括 '.' 和 '..'）。可选的 options 参数可以是指定编码的字符串，也可以是具有 encoding 属性的对象，该属性指定用于传给回调的文件名的字符编码。 如果 encoding 设置为 'buffer'，则返回的文件名是 Buffer 对象。如果 options.withFileTypes 设置为 true，则 files 数组将包含 fs.Dirent 对象。 fs.mkdir(path[, options], callback) path options recursive 默认值: false。 mode Windows 上不支持。默认值: 0o777。 callback err异步地创建目录。 除了可能的异常，完成回调没有其他参数。可选的 options 参数可以是指定模式（权限和粘滞位）的整数，也可以是具有 mode 属性和 recursive 属性（指示是否应创建父文件夹）的对象。1234// 创建 /tmp/a/apple 目录，无论是否存在 /tmp 和 /tmp/a 目录。fs.mkdir('/tmp/a/apple', { recursive: true }, (err) => {if (err) throw err;}); fs.copyFile(src, dest[, flags], callback) src要拷贝的源文件名。 dest拷贝操作的目标文件名。 flags用于拷贝操作的修饰符。默认值: 0。 callback异步地将 src 拷贝到 dest。 默认情况下，如果 dest 已经存在，则覆盖它。 除了可能的异常，回调函数没有其他参数。 Node.js 不保证拷贝操作的原子性。 如果在打开目标文件用于写入后发生错误，则 Node.js 将尝试删除目标文件。flags 是一个可选的整数，指定拷贝操作的行为。 可以创建由两个或更多个值按位或组成的掩码（比如 fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE）。 fs.constants.COPYFILE_EXCL - 如果 dest 已存在，则拷贝操作将失败。 fs.constants.COPYFILE_FICLONE - 拷贝操作将尝试创建写时拷贝（copy-on-write）链接。如果平台不支持写时拷贝，则使用后备的拷贝机制。 fs.constants.COPYFILE_FICLONE_FORCE - 拷贝操作将尝试创建写时拷贝链接。如果平台不支持写时拷贝，则拷贝操作将失败。123456const fs = require('fs');// 默认情况下将创建或覆盖目标文件。fs.copyFile('源文件.txt', '目标文件.txt', (err) => {if (err) throw err;console.log('源文件已拷贝到目标文件');}); 如果第三个参数是数字，则它指定 flags: 1234const fs = require('fs');const { COPYFILE_EXCL } = fs.constants;// 通过使用 COPYFILE_EXCL，如果目标文件存在，则操作将失败。fs.copyFile('源文件.txt', '目标文件.txt', COPYFILE_EXCL, callback); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"}]},{"title":"http爬虫和模块化","date":"2019-06-21T12:16:08.207Z","path":"/posts/4a117b12/","text":"http爬虫 和 模块化 http爬虫 12345678910111213141516171819202122232425262728293031323334const https = require(\"https\");const cheerio = require('cheerio');const req = https.get(\"https://www.17k.com/all\", (res) => { // res response 响应( 回馈 ) res.setEncoding('utf8'); // 得到结果的编码 let rawData = ''; res.on('data', (chunk) => { rawData += chunk; }); res.on('end', () => { try { //console.log(rawData) // html string const $ = cheerio.load(rawData) $('.td3 a').each(function(i, ele) { console.log($(this).text()) }) } catch (e) { console.error(e.message); } });}).on('error', (e) => { console.error(`Got error: ${e.message}`);});req.end() http web服务器渲染数据发送前台 1234567891011121314151617181920212223242526272829303132333435363738394041424344const https = require(\"https\");const http = require(\"http\");const cheerio = require('cheerio');const port = 8000;const host = 'localhost';const server = http.createServer(function(request, response) { response.writeHead(200, { 'Content-Type': 'text/html;charset=utf8' // 'Content-Type': 'text/html' }) const req = https.get(\"https://www.17k.com/all\", (res) => { // res response 响应( 回馈 ) res.setEncoding('utf8'); // 得到结果的编码 let rawData = ''; res.on('data', (chunk) => { rawData += chunk; }); res.on('end', () => { try { //console.log(rawData) // html string const $ = cheerio.load(rawData) $('.td3 a').each(function(i, ele) { response.write(`${ $(this).text() }`) }) response.end(); } catch (e) { console.error(e.message); } }); }).on('error', (e) => { console.error(`Got error: ${e.message}`); }); req.end()}).listen(port, host, function() { console.log(`http://${host}:${port}`)}) 中文乱码 123456789101112131415161718192021222324252627282930/* 服务器： 可以运行在服务端一个网站（站点） 种类： 1. web服务器（ 静态服务器 ） ，可以运行在浏览器中的服务器 2. api服务器 （ 后端接口 ） 后端语言暴露一个数据接口，用于前端数据请求（ ajax fetch ） Node.js中原生创建web服务器 http模块 createServer( callback ) 创建服务器 callback中接收三个参数 request response listen(port,host,callback) 监听服务器（ 反馈服务器状态 ） port 端口 host 域名 Node.js中中文乱码 1. 设置请求头 response.writeHead( 200, { 'Content-Type': 'text/html;charset=UTF8' // 小写也可以 utf8 }) 2. 发送一个meta标签 response.write('') 3. toString() 在当前应用场景中还不行 二进制有效 将二进制 --- 》 string 名词： chunk 分片 我们刚才发送了一个html给前台，那么这种渲染数据的形式我们称之为： ‘后端渲染’，也称之为：‘服务端渲染’，英文叫法： ‘ssr’*/ 2. 前端模块化 问题： 为什么前端要使用模块化？ 模块化： 是具有特定功能的一个对象（ 广义理解 ） 模块定义的流程： 1.定义模块（对象） 2.导出模块 3.引用模块 好处： 可以存储多个独立的功能块 复用性高 种类 AMD（ require.js） CMD ( sea.js ) Common.js AMD定义一个模块 define 1234567891011121314151617// AMD/* 目录 admDir a.js index.js*/// AMD定义 a.js define ({ a: 1, b: 2, add: function(){} })// AMD引用 index.js require([./a.js],function( moduleA ){ //moduleA指的就是定义来的对象 }) CMD定义模块 define 1234567891011121314151617//CMD/* 目录结构 b.js index.js*/// 模块定义 b.js define(function(require, exports, module) { // 模块代码 });//模块引用 index.js require('./b.js',function( moduleB ){ //moduleB就是b模块中导出的内容 }) Common.js Node.js使用了Common.js的规范 易错的理解： common.js是属于node的 × node属于common.js ×1234567891011121314//common.js/* 目录结构： name.js index.js*///模块的定义 name.js const nameObj = { name: 'Gabriel Yan ' }//模块的导出 name.js module.exports = nameObj//模块的引用 const nameObj = require('./name.js') Node.js中Common.js规范的使用有三种类型： 内置模块（ 内置模块指的是挂载在Node.js全局对象身上的api ） 自定义模块 模块的定义 123456//举例const student = { id: 1, name: 'Gabriel Yan'}const fn = function(){} 模块的导出 123456// 第一种导出module.exports = student // 安全性不高 默认导出一个//第二种导出module.exports = { //批量导出，按需引用 student,fn} 模块的引用 1234// 这种引用对应第一种导出const student = require('./xxx.js')// 这种引用对应第二种导出const { student , fn } = require( './xxx.js ' ) 注意： 在自定义模块引用时，require一定要写好路径 第三方模块 12345678910111. 别人已经封装好的模块2. 这个模块具备一些特定的功能3. 这些模块存放在 www.npmjs.com 这个网站中这些模块的文档也记录在内格式： var/let/const 变量名 = require( 模块名称 ) 总结： 第一步，使用npm/cnpm 安装 第二部，在文件中引入 第三部，在www.npmjs.com这个网站中找到这个模块的文档，根据文档来使用 思考： 我们是不是能将自己封装的自定义模块变成第三方模块？ 分析： 第三方模块具备的特性： 有一定的功能2. 存储在: http://www.npmjs.com 中 解决： 自定义模块的上传（ http://www.npmjs.com ） 创建package.json文件 1$ npm init -y 在http://www.npmjs.com 这个网站注册一个账号 注意：第一次登陆会发送一个邮件给你的邮箱（ 这个发送是手动的 ），然后大家登陆邮箱激活 检查你的电脑的源是不是npm源 1$ nrm ls 如果是，就不会理会 如果不是，那么切换到npm源 命令行登录npmjs仓库 1$ npm adduser 创建模块并导出模块 查看你的包名称是否已经被使用 发布包 1$ npm publish 犯错点： 邮箱没有激活 （ 最多的 ） npm源没有切换 整个电脑的npm就不能使用 -D === –save-dev 1234//举例cnpm i jquery -D === cnpm i jquery --save-dev // 开发环境下使用cnpm i jquery -S === cnpm i jquery --save // 生产环境下使用 ​ Node.js跨域 跨域； 前端跨域 jsonp 反向代理（ 创建一个虚拟后端服务器，让这个后端服务器帮助我们请求数据） 后端跨域 node php java 设置请求头 使用第三方的中间件（ cors ） 中间件： 就是具有一定功能的一个函数 前端模块化1. amd AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。 首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。 1234567891011121314151617/** 网页中引入require.js及main.js **//** main.js 入口文件/主模块 **/// 首先用config()指定各模块路径和引用名require.config({ baseUrl: \"js/lib\", paths: { \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", }});// 执行基本操作require([\"jquery\",\"underscore\"],function($,_){ // some code here});复制代码 引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。 12345678910111213141516171819202122232425262728// 定义math.js模块define(function () { var basicNum = 0; var add = function (x, y) { return x + y; }; return { add: add, basicNum :basicNum };});// 定义一个依赖underscore.js的模块define(['underscore'],function(_){ var classify = function(list){ _.countBy(list,function(num){ return num > 30 ? 'old' : 'young'; }) }; return { classify :classify };})// 引用模块，将模块放在[]内require(['jquery', 'math'],function($, math){ var sum = math.add(10,20); $(\"#sum\").html(sum);}); ​ 2. cmd- require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码： 1234567define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.foo() } }); CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。 123456789101112131415161718192021222324252627282930313233/** AMD写法 **/define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() } });/** CMD写法 **/define(function(require, exports, module) { var a = require('./a'); //在需要时申明 a.doSomething(); if (false) { var b = require('./b'); b.doSomething(); }});/** sea.js **/// 定义模块 math.jsdefine(function(require, exports, module) { var $ = require('jquery.js'); var add = function(a,b){ return a+b; } exports.add = add;});// 加载模块seajs.use(['math.js'], function(math){ var sum = math.add(1+2);});3.ES6 Module- ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。 123456789101112/** 定义模块 math.js **/var basicNum = 0;var add = function (a, b) { return a + b;};export { basicNum, add };/** 引用模块 **/import { basicNum, add } from './math';function test(ele) { ele.textContent = add(99 + basicNum);}​ ​ 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。 12345678/** export default **///定义输出export default { basicNum, add };//引入import math from './math';function test(ele) { ele.textContent = math.add(99 + math.basicNum);} ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。 4.ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"}]},{"title":"MongoDB","date":"2019-06-21T12:10:16.785Z","path":"/posts/0/","text":"MongoDBMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 常用命令1234567891011121314151617181920212223242526272829303132333435363738show dbs 查看数据库use dbname 创建数据库 如果不存在创建数据库，否则切换到数据库show collections 显示数据库集合1.添加数据 db.web.save({\"name\": \"meiejuna\"}) 创建了名称为 web 的名称，名 db.web.insert({\"name\": \"meijuna\"}) 插入相同的数据，sava 覆盖，insert 报错 2.删除数据 db.students.remove( {} ) 删除 students 集合下的所有数据 db.students.remove({\"name\": \"meijuna\" }) 删除 students 集合为 name 为 meijuna 的数据 db.students.drop() or db.runCommand({\"\"})删除 students 集合 db.runCommand( { dropDaatabase: 1 } ) 删除当前数据库 3.修改数据db.students.updata({\"name\": \"meijuna\"},set:{\"sex\":\"women\"}) 单行修改db.students.updata({\"name\": \"meijuna\"},{$set:{\"sex\":\"women\"}}, true, true) 多行修改 //{查找条件} , { 修改内容 } 匹配所有条件数据 修改所有匹配项4.查找数据 db.students.find() 查找 students 集合中的 所有 数据 db.students.findONe() 查找 students 集合中的 第一条 数据 db.students.find().pretty() 可视化查询 5.排序 db.students.find().sort({\"age\": 1}) 1 升 -1 降序6.截取db.students.find().skip(2) 下标为 2 开始截取db.students.find().limit(2) 截取 2 条数据7.筛选显示db.students.find({age:20},{_id:0,age:1,name:1}) 0,筛选的结果不显示，1筛选结果显示 SQL简介 关系型数据库 以行和列的形式存储数据，以便于用户理解。这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。 关系型数据库有：mySql oracle SqlServer Access *db2 * 等 NoSQL简介 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 非关系型数据库: MongoDB，Redis，HBase，*CouchDB * 等 非关系型数据库与关系型数据库区别关系型数据库的优势：1. 复杂查询 可以用SQL语句方便的在多个表之间做非常复杂的数据查询。 2. 事务支持 使得对于安全性能很高的数据访问要求得以实现。 非关系型数据库的优势：1. 性能 NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2. 可扩展性 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 MongoDB优点它的特点是高性能、易部署、易使用，存储数据非常方便。 主要功能特性有： 面向集合存储，易存储对象类型的数据。 模式自由。 支持动态查询。 支持完全索引，包含内部对象。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象（如视频等）。 自动处理碎片，以支持云计算层次的扩展性 支持RUBY，PYTHON，JAVA，C++，PHP等多种语言。 文件存储格式为BSON（一种JSON的扩展） #### BSON 存储格式BSON是一种类似json的二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，**如Date和BinData类型。 BSON有三个特点：轻量性、可遍历性、高效性。 非关系型数据库文件存储格式为 BSON（一种JSON的扩展）。 MongoDB下载与安装1. MongoDB下载：https://www.mongodb.com/download-center#community 2. 设置环境变量在环境变量窗口中一般有两个变量，一个是你当前所使用的用户独有的环境变量，另一个是所有用户都可以访问的系统变量。其实如果在你的电脑上你只使用一个用户的话，那么不管你修改的用户的环境变量还是系统变量，效果都是一样的。为了以防未来会新建其他用户，那么我建议你修改系统变量而不是某个用户独有的环境变量。 3. 测试连接 管理员身份运行 cmd 输入 mongo 启动 mongdb 服务 net start mongdb 关闭 mongdb 服务 net stop MongoDB 4. 安装可视化工具(Robo 3T)https://robomongo.org/download node 使用 MongoDB 连接 MongoDB 123456789101112131415//1. 下载 mongoose cnpm i mongoose -D //2. 引入 mongoose const mongoose = require( 'mongoose');//3. 连接 mongoose // 连接本地mongodb ，本机的ip 127.0.0.1，端口：27017 数据库：studentmongoose.connect(\"mongodb://127.0.0.1:27017/student\",function(err){ if(!err){ console.log(\"connected to Mongodb\"); //连接成功 }else{ throw err;//如果连接失败，则抛出异常 }}); 存储数据 Schema不仅定义了文档结构和使用性能，还可以有扩展插件、实例方法、静态方法、复合索引、文档生命周期钩子。 12345Schema ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力Model ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对Entity ： 由Model创建的实体，他的操作也会影响数据库 存储数据步骤：定义Schema (骨架) > 创建model（模型）> Entity实例化方法。 1234567891011121314151617181920212223242526272829const mongoose = require( 'mongoose');const Schema = mongoose.Schema;mongoose.connect( 'mongodb://127.0.0.1:27017/meijuna',(error) => { if ( error ) { throw error } else { console.log( 'database is connected~') }})const userSchema = new Schema({ //定义数据模型 username: String, password: String})//通过模式studentSchema 创建一个模型studentModel var studentModel = mongoose.model(\"students\",studentSchema );var instance1 = new studentModel (); instance1.name=\"tangyan\";instance1.age=\"18\";instance1.save(function(err){ //通过save方法保存 if (err) { console.log('保存失败'); return; } }); 查询数据 12345// 查userModel.find({}, ( error, result ) => { if ( error ) throw error console.log ( result )}) 修改数据 123456789101112131415userModel.find({ username: 'aaa'}, ( error, result) =>{ if (error) throw error const _id = result[0]._id userModel.findById(_id, ( error, doc ) => { // 修改 if (error ) throw error console.log( doc ); doc.username = \"meijuna\"; doc.save ( (error) => { throw error console.log(\"数据修改成功\") }) })}) 删除数据 1234567891011121314userModel.find({ username: 'aaa'}, ( error, result) =>{ if (error) throw error const _id = result[0]._id userModel.findById(_id, ( error, doc ) => { // 删除 if (error ) throw error doc.remove( (error) => { if (error) throw error console.log('数据删除成功！') }) })}) 注册 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const mongoose = require('mongoose');const Schema = mongoose.Schema;mongoose.connect('mongodb://127.0.0.1:27017/meijuna', (error) => { if (error) { throw error } else { console.log('database is connected !!!') }})const userSchema = new Schema({ //定义数据模型 username: String, password: String})const userModel = mongoose.model('users', userSchema) //模型创建const user = new userModel(); //创建实体router.get('/', (req, res, next) => { const { username, password } = req.query; console.log(username,password); userModel.find({}, (error, result) => { var flag = result.some((item) => { return item.username === username }) if (flag) { //用户名存在 res.render('register', { data: JSON.stringify({ ret: true, //身份验证 权限验证 status: 2 //0 表示失败 1：成功 2： }) }) } else { user.username = username; user.password = password; user.save(); res.render('register', { data: JSON.stringify({ ret : true, status: 1 }) }) } })}) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据库","slug":"数据库","permalink":"https://yhk15978.github.io/tags/数据库/"}]},{"title":"express Node 核心框架","date":"2019-06-21T12:02:11.085Z","path":"/posts/4a17b112/","text":"express Node 核心框架express是一个功能极简, 完全是由路由和中间件构成的一个web开发框架,是非侵入式的框架 1. 为什么要使用 express ?1234567- express 是 Node 的核心框架- express 可以帮助我们快速构建 web 服务器 / api 服务器- express 提供了一个快速生成工具 express-generator - 快速生成工具： 帮助我们快速创建一个项目的工具 2. 安装方式1. 全局安装123$ npm i express-generator -g or $ yarn add express-generator -g 2. npx 安装12345(如果npm版本在 5.2+，那可以不用全局，用npx)$ npx express -e express_demo -e : 指的是我们使用一个叫 ejs 的模板（ejs.js 可以兼容html标签, 可以在标签中写 js ） 3. 项目目录 bin www 启动了一个静态服务器 （ web服务器 ） node_modules 这个项目的依赖包 public 静态资源文件 ( html，css，images) routes 路由文件夹 view xxx.ejs （ 项目模板 ) app.js ( 这个项目的入口文件 ) 4. app.js 文件代码解读123456- app对象的功能 1. 通过app.use来使用具有特定功能的函数 ( 又叫中间件 )- 中间件分类 1. 应用中间件 （ cors ) 2. 路由中间件 app.get( '/' , (req, res, next ) => { } ) 3. 错误处理中间件 function( err, req, res, next ) { } 5. express 创建 api 服务器 （ 创建接口 ） api 服务器是给前端提供接口数据 api 服务器需要使用的给测试工具来测试，不能用浏览器展示 注意： 后端个前端发送的数据类型是 JSON 字符串，前端需要 JSON.parse() 转换成对象 6. restful api 规则restful aip 规则 是一个暴露接口的规则 ，实现是一个接口使用不同的数据请求方式来实现不同的功能总结： 使用restful api 来暴露接口（ 多个数据请求的接口 ） cors中间件的跨域 前端发来的数据， 后端如何接受 get req.query post req.body 7. 数据请求格式1. get 发送数据时，携带的参数时，形式是 Query string Parameters 后端 req.query 获取前端传来的数据 2. post 发送数据时，携带的参数时，形式是 Form Data 前端 req.body 获取前端传来的数据 8. ecj 模板ecj 官网 EJS 是一套简单的模板语言，帮你利用 JavaScript 代码生成 HTML 页面。 12345ejs模板语法: 执行正常js代码 转移输出 非转义输出 后端接口文档 ( 模板来写 )https://www.showdoc.cc/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"}]},{"title":"前端异步流程","date":"2019-06-21T11:20:20.187Z","path":"/posts/4a17b158/","text":"前端异步流程1. 传统的原生异步- 回调函数 - 事件2. 使用异步流程工具（ 别人封装好的东西 ）- es6 Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* Promise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise 所谓Promise ，简单说就是一个容器，里面保存着某个未来才回结束的事件(通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。 Promise 对象的状态不受外界影响 三种状态: pending：进行中 fulfilled :已经成功 rejected 已经失败 状态改变： Promise对象的状态改变，只有两种可能： 从pending变为fulfilled 从pending变为rejected。 这两种情况只要发生，状态就凝固了，不会再变了，这时就称为resolved（已定型）*/ const p1 = new Promise((resolve, reject) => { resolve('任务一') }).then(data => { console.log(data); return data; }) const p3 = new Promise((resolve, reject) => { setTimeout(() => { resolve('任务三') }, 1000) }).then(data => { console.log(data); return data; }) const p2 = new Promise((resolve, reject) => { setTimeout(() => { resolve('任务二') }, 2000) }).then(data => { console.log(data) return data }) console.log('主线程任务') //主线程任务 // all race // 如果作为参数的Promise实例自身定义了catch方法，那么它被rejected是并不会触发Promise.all()的catch方法 // Promise.all中都成功返回才执行 Promise.all([p1, p2, p3]).then(data => { //data为p1,p2,p3返回值组成的数组 console.log(data) //[ '任务一', '任务二', '任务三' ] }).catch(e => console.log(e)) // Promise.race中只要有一个成功返回就执行 Promise.race([p1, p2, p3]).then(data => { //data为p1,p2,p3中最先成功的返回值 console.log(data) //任务一 }) // 以上代码执行结果为 // 主线程任务 // 任务一 // 任务一 // 任务三 // 任务二 // [ '任务一', '任务二', '任务三' ] - es6 generator函数123456789101112131415161718192021/*generator函数在function关键字后面加一个* 这样定义的函数就叫做generator函数通过yield关键字来定义任务通过fn().next() 来执行任务value表示yield关键字后任务执行的结果done表示当前定义的所有的任务是否执行完成的一个状态理解：多任务的定义，多任务执行让自己定义的多个任务依次执行，上一个任务如果没有完成，下一个任务就不会开始*/function* fn() {yield '任务一'yield '任务二'return '任务'}const a = fn()console.log(a.next()) // { value: '任务一'，done: false }console.log(a.next()) //{ value: '任务二', done: false }console.log(a.next()) //{ value: '任务', done: true }console.log('主线程任务') //主线程任务 es6( 7 ) async 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*async函数es6提供配合关键字 await使用await 表示，等待，任务一执行结束之后，才会执行任务二async函数返回值为Promise对象*/async function fn() { const result = await '任务一' console.log(result) console.log('任务二')}fn()const fn1 = async() => {const res = await new Promise((res, rej) => { setTimeout(() => { res('任务3') }, 2000) }).then(result => { console.log(result) return result;})let req = await new Promise((res, rej) => { setTimeout(() => { res('任务四') }, 1000) }).then(result => { console.log(result) return result;}) console.log(req) console.log(res)if (false) { return req} else { throw res}//返回值通过then()调用，抛出值通过catch()调用}fn1().then(re => console.log(re)).catch(re => console.log(re))//结果:// 任务一// 任务二// 任务3// 任务四// 任务四// 任务3// 任务3 - node.js中的 nextTick setImmudiate 1234567nextTick()的回调函数执行的优先级要高于setImmediate();process.nextTick()属于idle观察者,setImmediate()属于check观察者.在每一轮循环检查中,idle观察者先于I/O观察者,I/O观察者先于check观察者.在具体实现上,process.nextTick()的回调函数保存在一个数组中,setImmediate()的结果则是保存在链表中.在行为上,process.nextTick()在每轮循环中会将数组中的回调函数全部执行完.而setImmediate()在每轮循环中执行链表中的一个回调函数.nextTick > 回调函数 > setImmediate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*Node.js提供的nextTicksetImmediate*///加入2个nextTick()的回调函数process.nextTick(function(){ console.log(\"nextTick延迟执行A\");});process.nextTick(function(){ console.log(\"nextTick延迟执行B\");setImmediate(function(){ console.log(\"setImmediate延迟执行C\");});process.nextTick(function(){ console.log(\"nextTick延迟执行D\");});});//加入两个setImmediate()回调函数setImmediate(function(){ console.log(\"setImmediate延迟执行E\");process.nextTick(function(){ console.log(\"强势插入F\");});setImmediate(function(){ console.log(\"setImmediate延迟执行G\");});});setImmediate(function(){ console.log(\"setImmediate延迟执行H\");process.nextTick(function(){ console.log(\"强势插入I\");});process.nextTick(function(){ console.log(\"强势插入J\");});setImmediate(function(){ console.log(\"setImmediate延迟执行K\");});});console.log(\"正常执行L\");// 正常执行L// nextTick延迟执行A// nextTick延迟执行B// nextTick延迟执行D// setImmediate延迟执行E// setImmediate延迟执行H// setImmediate延迟执行C// 强势插入F// 强势插入I// 强势插入J// setImmediate延迟执行G// setImmediate延迟执行K - 第三方的 async.js 库 12345678910111213141516171819202122232425262728293031323334353637383940414243/*async.js第三方的库案例：parallelseries功能：1. 可以实现异步2. 串行series和并行parallel*/const async = require( 'async' ) async.series({ one: function ( callback ) { setTimeout( function () { callback( null, 1)},200)},two: function ( callback ) {setTimeout( function () { callback ( null , 2 )},100)}}, function ( error , results ) { console.log( 'series',results )}) console.log( '主线程' )async.parallel({ one: function ( callback ) {setTimeout( function () { callback( null, 1)},200)},two: function ( callback ) { setTimeout( function () { callback ( null , 2 )},100)}}, function ( error , results ) { console.log( 'parallel',results )}) // 主线程// parallel { two: 2, one: 1 }// series { one: 1, two: 2 } 总结： 异步流程的任务是放在异步队列中的，异步队列只有在主线程执行完之后采取执行 参考资料 Promisehttps://blog.csdn.net/MrJavaweb/article/details/79475949 Generatorhttps://www.cnblogs.com/imwtr/p/5913294.html Async-await Node.js 中的nextTick()和setimmediate()https://www.cnblogs.com/5ishare/p/5268273.html async库https://caolan.github.io/async/参考文档Event-loophttp://www.ruanyifeng.com/blog/2014/10/event-loop.html?bsh_bid=983729729史上最易读懂的 Promise/A+ 完全实现https://zhuanlan.zhihu.com/p/21834559 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"}]},{"title":"vue基础语法","date":"2019-06-19T11:59:36.232Z","path":"/posts/4a17b157/","text":"vue基础语法mutache 语法糖123456&lt;div id=\"app\"&gt; &lt;p&gt; {{ this.msg }} &lt;/p&gt; &lt;p&gt; {{ this.$data.msg }} &lt;/p&gt; &lt;p&gt; {{ this._data.msg }} &lt;/p&gt; &lt;p&gt; {{ msg }} &lt;/p&gt;&lt;/div&gt; jsx: javascript + xml可以让我们在dom结构中输写javascript 是 this.msg 简写this.$data.msg -> this.msg -> msg mustache语法糖对数据类型的支持（ js语法的支持 ）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt; number: {{ num }} &lt;/p&gt; &lt;p&gt; string: {{ str }} &lt;/p&gt; &lt;p&gt; boolean: {{ bool }} &lt;/p&gt; &lt;p&gt; null: {{ nul?'1':'2' }} &lt;/p&gt; &lt;p&gt; undefined: {{ und && 1 || 2 }} &lt;/p&gt; &lt;p&gt; object: {{ obj.name }} &lt;/p&gt; &lt;p&gt; array: {{ arr[0] }} &lt;/p&gt; &lt;p&gt; fn: {{ fn() }} &lt;/p&gt; &lt;!-- &lt;p&gt; console.log: {{ console.log( 1 ) }} &lt;/p&gt; &lt;p&gt; alert: {{ alert( 2 ) }} &lt;/p&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; /* 数据类型： 第一种划分： 基础数据类型： number string boolean 复杂数据类型: Object( array function ) 特殊数据类型: null undefined 第二种划分： 初始数据类型: number string boolean null undefined 引用数据类型: object( array function ) 结论： mustache支持我们js的数据类型的 conosle.log 和 alert 在我们mustache语法中是不支持的 */var vm = new Vue({ el: '#app', data: { num: 100, str: 'hello Vue.js', bool: true, nul: null, und: undefined, obj: { name: 'yhk' }, arr: [1,2,3,4], fn: function () { alert( 2 ) return '这是一个函数' } }})&lt;/script&gt; mustache 绑定 dom的属性123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;p v-html = \"h\"&gt;&lt;/p&gt; &lt;p v-text = \"msg\"&gt;&lt;/p&gt; &lt;p v-text = \" flag && 1 || 2 \" &gt; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; /* 案例： v-html 分析： 发现dom元素直接有了一个内容 这种属性绑定就是为了操作dom 结论： 这种属性绑定的形式就是为了操作dom，我们给这种属性起了一个好听的名字 Vue 1.0 叫它 属性指令（ 借鉴Angular来的 ） Vue 2.0 统称为 ‘指令’ 指令是用一个 v-xxx 表示 指令是用来操作dom Vue中不允许直接操作dom!!! mustache语法 --- 属性写法 的属性值是直接写数据的，不需要使用 {{ }} */var vm = new Vue({ el: '#app', data: { msg: 'hello Vue.js', h: '&lt;h3&gt; hello Vue.js &lt;/h3&gt;', flag: true } })&lt;/script&gt; 问题： 我们说vue是 MVVM 框架， 那么谁是 M 谁是 V 谁是 VM 1234567891011121314151617&lt;!-- V --&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script&gt; /* M： Model 数据 V： View 视图 VM: ViewModel 视图模型（ new Vue() ） */ var vm = new Vue({ el: '#app',//给跟实例一个模板（ 挂载 ） data: { //M } })&lt;/script&gt; 指令： ( 是绑定在dom属性上 )v-html:可以解析标签型数据( 可以将一个数据展示在一个dom的内容中（ 相当于使用了 innerHTML ）) v-text：可以将一个数据展示在一个dom的内容中（ 相当于使用了 innerHTML ）条件渲染的指令 v-show可以控制一个dom的显示隐藏（ 这个指令操作的是dom的display属性 ） v-if可以控制一个dom的存在与否（ 创建 和 销毁 ） v-elsev-else-if123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;h3&gt; v-show &lt;/h3&gt; &lt;p v-show = \"showFlag\"&gt; v-show指令 &lt;/p&gt; &lt;hr&gt; &lt;h3&gt; v-if - 单路分支 &lt;/h3&gt; &lt;p v-if = \"ifFlag\"&gt; v-if - 指令的单路分支 &lt;/p&gt; &lt;h3&gt; v-if - 双路分支 &lt;/h3&gt; &lt;p v-if = \"ifFlag\"&gt; 双路分支 成立 &lt;/p&gt; &lt;p v-else&gt; 双路分支不成立 &lt;/p&gt; &lt;h3&gt; v-if - 多路分支 &lt;/h3&gt; &lt;p v-if = \" type === 'A'\"&gt; A &lt;/p&gt; &lt;p v-else-if = \" type === 'B'\"&gt; B &lt;/p&gt; &lt;p v-else&gt; C &lt;/p&gt; &lt;/div&gt;&lt;script&gt;var vm = new Vue({ el: '#app',//给跟实例一个模板（ 挂载 ） data: { showFlag: true, ifFlag: false, type: 'A' }})&lt;/script&gt; 实用题 v-if vs v-show 区别 实用： 项目中 如何选择这两个使用 v-if 操作的是dom元素（ 组件 ） 的创建或是销毁 v-show 操作的是dom元素的display属性 v-if可以有多种使用形式： 单路分支， 多路分支， 双路分支 v-show 只能写一个单路形式一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-for 数组 v-for = “ (item,index) in arr “ item是arr中每一个元素 对象 v-for = “(item,key,index) in obj “ item是obj的属性值 json类型数据 嵌套类型数据 key:给没一个循环的列表添加一个唯一的标识使用指令 v-bind 来绑定 key如果有id，那么我们就使用id，如果没有，我们才会选择indexv-bind: 单项数据绑定： 将一个数据绑定在一个dom的属性上简写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;div id=\"app\"&gt; &lt;h3&gt; 数组 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \" (item,index) in arr \" v-bind:key = \"index\"&gt; &lt;p&gt; item :{{ item }} -- index: {{ index }}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; 对象 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \"(item,key,index) in obj\" v-bind:key = \"index\"&gt; &lt;p&gt; value: {{ item }} -- key: {{ key }} -- {{ index }} &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; json &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \"(item,index) of json\" v-bind:key = \" item.id \"&gt; &lt;p&gt; id: {{ item.id }} &lt;/p&gt; &lt;p&gt; task: {{ item.task }} &lt;/p&gt; &lt;p&gt; {{ index }} &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; 嵌套 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \" item in lists \" :key = \"item.id\"&gt; &lt;p&gt; id: {{ item.id }} &lt;/p&gt; &lt;ul&gt; &lt;li v-for = \"todo in item.todos\"&gt; todos中的数据 -- {{ todo }} &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { arr: [1,2,3,4], obj: { id: 1, name: '骏哥', sex: 'man', age: 18 }, json: [ { id: 1, task: '敲代码1' }, { id: 2, task: '敲代码2' } ], lists: [ { id: 1, todos: { id: 1, name: '连城' } }, { id: 2, todos: { id: 2, name: '文武' } } ] } })&lt;/script&gt; vue中如何给dom添加类名 直接在dom上绑定类名 vue中类名绑定 - 对象形式目的： dom身上属性class 要和 数据绑定解决：v-bind数据中key，我们起的和绑定的对象中的key一样，但是你得知道这两个东西不一样&lt;p :class = \"{ size,bg_color }\"&gt;&lt;/p&gt;size是自定义的属性， 它的属性值是undefined， 相当于是false&lt;p :class = \"{ size: true, bg_color: true }\"&gt;&lt;/p&gt;size也是自定义属性，他的属性是true,那么就会加上去&lt;p :class = \"{ [s]: true, [bg_color]: true }\"&gt;&lt;/p&gt;格式： v-bind:class = \"{ 属性： boolean }\"格式： v-bind:class = \"{ [data]： boolean }\" vue中类名绑定的形式 - 数组的形式 【 推荐 】格式： v-bind:class = \"[ 数据 ]\" 类名绑定不会覆盖原先的类名 为什么要绑定类名指令是用来操作dom目的： 为了将来通过数据来操作类名，类名操作dom12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; .size{ width: 100px; height: 100px; } .bg_color{ background: red; }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;h3&gt; v-class &lt;/h3&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加第一种 &lt;/h3&gt; &lt;p class=\"size bg_color\"&gt;&lt;/p&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加第二种 - 对象的形式&lt;/h3&gt; &lt;p :class = \"{ size: true,bg_color: false }\"&gt;&lt;/p&gt; &lt;p :class = \"{ size: true, bg_color: true }\"&gt;&lt;/p&gt; &lt;p :class = \"{ [s]: true, [bg_color]: true }\"&gt;&lt;/p&gt; &lt;p :class = \"{ [s]: 5&gt;3?true: false, [bg_color]: true }\"&gt;&lt;/p&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加的第三种形式 - 数组形式（ 推荐 ）&lt;/h3&gt; &lt;p :class = \"['size','bg_color']\"&gt;&lt;/p&gt; &lt;p :class = \"[ s, bg_color ]\"&gt;&lt;/p&gt; &lt;p :class = \"[ flag? s:'box', bg_color]\"&gt;&lt;/p&gt; &lt;p :class = \"[ flag? s:'box', bg_color]\" class = \"yyb\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data: { msg: 'hello Vue.js', s: 'size', bg_color: 'bg_color', flag: true } }); var a = { name: 'yhk' } var b = { name: 'mjn' }&lt;/script&gt; 样式的绑定：v-bind:style = “” 对象的形式 数组的形式12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;h3&gt; style &lt;/h3&gt; &lt;hr&gt; &lt;h3&gt; style - 对象形式 &lt;/h3&gt; &lt;p :style = \"{ width: size.width,height: size.height,background: 'red'}\"&gt;&lt;/p&gt; &lt;h3&gt; style - 数组的形式 &lt;/h3&gt; &lt;p :style = \"[ { width: '100px',background: 'blue'},{ height: '100px' } ]\"&gt; &lt;/p&gt; &lt;p :style = \"[ size,bg ]\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { size: { width: '100px', height: '100px' }, bg: { background: 'purple' } } })&lt;/script&gt; 事件问题： javascript事件添加有几种形式 事件绑定dom.onclick = function () {}dom: 事件源on: 绑定事件的形式click: 事件类型function（）{} 事件处理函数 事件监听 ：addeventListener 直接在标签中绑定事件&lt;div onclick = \"事件名称\"&gt;&lt;/div&gt;vue采用了第三种，也是通过属性的形式绑定在dom身上&lt;div v-on:click = \"事件名称\"&gt;&lt;/div&gt;简写：&lt;button @click = \"helloHandler\"&gt; 点击 &lt;/button&gt;v-on使用事件源事件绑定形式事件类型事件处理程序v-on:eventType = “ handlerName “简写 v-on: — > @ 问题： 函数调用有哪些方法？直接调用 ()事件事件对象也可以正常使用在事件处理程序中， 写e就可以了问题： 如果事件处理程序中有三个参数，第三个参数才是事件对象e,如何实现分析： 我们发现事件处理程序中的第三个参数 e 不在是事件对象了，而是一个undefined解决： 在函数执行时，传入一个实际参数 $event 来代表事件对象 问题： 如果我们通过 length = 0 , 来清空一个数组，那么vue检测不到这个变动解决方法： 使用splice问题： 我们直接修改一个数组下的一个数据时，发现下标不能检测变动了解决方法： 使用 Vue.set / this.$set 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;div id=\"app\"&gt; &lt;button @click = \"add\"&gt; + &lt;/button&gt; &lt;button @click = \"remove\"&gt; - &lt;/button&gt; &lt;button @click = \"indexHandler\"&gt; 修改第二条数据 &lt;/button&gt; &lt;ul&gt; &lt;li v-for =\" item in lists \" :key = \"item.id\"&gt; {{ item.task }} &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;button @click = \"arrChange\"&gt; 修改第二条数据 &lt;/button&gt; &lt;ul&gt; &lt;li v-for = \" (item,index ) in arr \" :key = \"index\"&gt; {{ item }} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;/*业务： 点击这个按钮，添加一条新的数据放在列表数据中*/new Vue({ el: '#app', data: { arr: [1,2,3], lists: [ { id: 1, task: '锻炼1' }, { id: 2, task: '敲代码' } ] }, methods: { add () { // console.log( this ) this.lists.push({ id: this.lists.length + 1, task: '打篮球' }) }, remove () { this.lists.pop() }, indexHandler () { //将列表中的第二个数据中的task任务修改为 撸猫 this.lists[1] = { id: 2, task: '骏哥' } // 将整个列表清空 // this.lists.length = 0 // this.lists.splice( 0 ) }, arrChange () { // this.arr[ 1 ] = '骏哥' 不可以检测到的 // this.$set( this.arr,'1','骏哥' ) Vue.set( this.arr,'1','骏哥') } } })&lt;/script&gt; v-model双向数据绑定默认绑定value值v-model应用于表单元素 1234567891011121314&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model = \"msg\"&gt; &lt;p&gt; {{ msg }} &lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: 'hello Vue.js' } })&lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"}]}]