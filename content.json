[{"title":"过滤器&过渡效果 && 动画 & 生命周期！！ & swiper&自定义指令","date":"2019-07-05T02:57:57.907Z","path":"/posts/yhk12342/","text":"过滤器 什么是过滤器？ 用来格式化数据的一个函数 $ 10 ‘$’ + price 日期的格式化vue 1.x 版本借鉴了 angular , 提供 10 个过滤器， 包括有： 日期 小数点位数保留 货币 大小写 等Vue 2.x 废弃了这 10个过滤器，但是它提供了自定义过滤器的方式 使用方式 全局定义过滤器1&lt;p&gt; {{ time | timeFilter('/')}} &lt;/p&gt; 123456789Vue.filter('timeFilter',function ( val,type ) { console.log( val ) //val 就是我们获得的数据 // return newVal return 的结果就是格式化之后的新数据 return的结果就是页面呈现的结果 type = type || '-' var date = new Date ( val ) // 2019-6-26 return date.getFullYear() + type + ( date.getMonth() + 1 ) + type + date.getDate()}) 局部定义过滤器 123456789101112new Vue({ el: '#app', data: { time: Date.now() }, filters: { //过滤器的配置项 'timeFilter': function ( val,type ){ var date = new Date ( val ) return date.getFullYear() + type + ( date.getMonth() + 1 ) + type + date.getDate() } }}) 过滤器要想获得我们的数据，要通过一个叫做 ‘管道符 | ’ 来获取数据 过滤器是对已经有的数据进行格式化，也就是必须先有数据，在去格式化 过渡效果 && 动画 使用形式 在 CSS 过渡和动画中自动应用 class Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理： 1. 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 2. 如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。 3. 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。 在进入/离开的过渡中，会有 6 个 class 切换。 1. `v-enter`：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 2. `v-enter-active`：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 3. ` v-enter-to`: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 `v-enter` 被移除)，在过渡/动画完成之后移除。 4. `v-leave`: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 5. `v-leave-active`：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 6. ` v-leave-to`: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时`v-leave`被删除)，在过渡/动画完成之后移除。 ![5990c1dff7dc7a8fb3b34b4462bd0105.png](en-resource://database/757:1) 案例： 123456&lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 1234new Vue({ el: '#demo', data: { show: true }}) 123456.fade-enter-active, .fade-leave-active { transition: opacity .5s;}.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ { opacity: 0; }对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了&lt;transition name=\"my-transition\"&gt;，那么 v-enter 会替换为 my-transition-enter。 v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线 可以配合使用第三方 CSS 动画库，如 Animate.css 123456789&lt;link href=\"https://cdn.jsdelivr.net/npm/animate.css@3.5.1\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;div id=\"example-3\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"custom-classes-transition\" enter-active-class=\"animated tada\" leave-active-class=\"animated bounceOutRight\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以在属性中声明 JavaScript 钩子 1234567891011&lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:after-enter=\"afterEnter\" v-on:enter-cancelled=\"enterCancelled\" v-on:before-leave=\"beforeLeave\" v-on:leave=\"leave\" v-on:after-leave=\"afterLeave\" v-on:leave-cancelled=\"leaveCancelled\" &gt; &lt;!-- ... --&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940// ...methods: { // -------- // 进入中 // -------- beforeEnter: function (el) { // ... }, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) { // ... done() }, afterEnter: function (el) { // ... }, enterCancelled: function (el) { // ... }, // -------- // 离开时 // -------- beforeLeave: function (el) { // ... }, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) { // ... done() }, afterLeave: function (el) { // ... }, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) { // ... } } 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 123456789101112&lt;!-- Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择 --&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;div id=\"example-4\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" v-bind:css=\"false\" &gt; &lt;p v-if=\"show\"&gt; Demo &lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 12345678910111213141516171819202122232425new Vue({ el: '#example-4', data: { show: false }, methods: { beforeEnter: function (el) { el.style.opacity = 0 el.style.transformOrigin = 'left' }, enter: function (el, done) { Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 }) Velocity(el, { fontSize: '1em' }, { complete: done }) }, leave: function (el, done) { Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 }) Velocity(el, { rotateZ: '100deg' }, { loop: 2 }) Velocity(el, { rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 }, { complete: done }) } }}) 过渡模式 mode 同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 过渡模式in-out：新元素先进行过渡，完成之后当前元素过渡离开。out-in：当前元素先进行过渡，完成之后新元素过渡进入。 12345678910111213141516171819&lt;link href=\"https://cdn.bootcss.com/animate.css/3.7.2/animate.css\" rel=\"stylesheet\"&gt;&lt;div id=\"app\"&gt; &lt;button @click = \"change\"&gt; 切换 &lt;/button&gt; &lt;transition mode = \"in-out\" enter-active-class = \"animated slideInLeft\" leave-active-class = \"animated slideOutLeft\" &gt; &lt;p v-if = \"flag\"&gt; on &lt;/p&gt; &lt;/transition&gt; &lt;transition mode = \"out-in\" enter-active-class = \"animated slideInLeft\" leave-active-class = \"animated slideOutLeft\" &gt; &lt;p v-if = \"!flag\"&gt; off &lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 1234567891011new Vue({ el: '#app', data: { flag: true }, methods: { change () { this.flag = !this.flag } }}) 生命周期 什么是生命周期？vue中的生命周期指的是 组件 从创建到销毁一个过程，在这个过程中，我们在每一个特定的阶段会触发一些方法（ 这些方法具备一些功能），我们给这些方法起了个名字叫做（ 生命周期钩子函数/ 组件钩子 ） 为什么要学习生命周期？因为我们想在生命周期钩子中实现项目功能，那么我们必须知道每一个钩子函数的具体用途 这个生命周期是谁的生命周期？组件 生命周期图示 lifecycle.png 如何使用生命周期钩子函数 Vue的生命周期分为三个阶段，分别为： 初始化，运行中， 销毁，一共8个钩子函数 注意： 生命周期钩子函数不允许写成箭头函数 初始化：beforeCreate 组件创建前触发，目的是为了组件的生命周期 和 组件中的事件做准备 数据没有获得，真实dom也没有渲染出来 可以进行数据请求，提供了一次数据修改的机会 执行一次created 组件创建结束 数据得到了，真实dom没有渲染出来 可以进行数据请求，提供了一次数据修改的机会 执行了一次beforeMount 组件挂载前 任务： 判断el 判断 template如果el没有，那么我们需要手动挂载，如果有，那么判断template如果template有，那么进行render函数如果template没有，那么通过 outerHTML 手动书写模板 数据可以获得，但是真实dom还没有渲染 可以进行数据请求，也提供了一次数据修改的机会 执行一次mounted 组件挂载结束 数据获得了，真实dom也获得了 可以进行数据请求，也就可以修改数据 执行了一次 可以进行真实dom的操作了（ 可以进行第三方库的实例化了 ）综上总结： 数据请求一般写在created里面 第三方库实例化我们一般会往mounted中写 运行中： 触发条件：数据更新beforeUpdate 1. 更新前 2. 重新渲染 VDOM , 然后通过diff算法比较两次vdom,生成patch 补丁对象 3. 这个钩子函数更多的是内部进行一些操作，我们就不在多干预了 4. 可以触发多次 updated 1. 更新结束 2. 真实dom得到了，数据也得到了（ 更新后的 ） 3. 动态数据获取（ 第三方库实例化 ） 销毁：触发条件： 当组件销毁时：beforeDestroydestroyed 这两个钩子功能一致的，这两个钩子没有太大的区别 作用：用来做善后的,比如计时器的关闭 第三方实例的删除 Vue的销毁有两种形式 通过开关的形式v-if - 外部销毁 通过调用 $destroy 方法 - 内部销毁 对比： 内部销毁 vs 外部销毁外部销毁不仅能销毁组件，也能销毁该组件的dom结构内部销毁只能销毁组件，不能销毁组件的dom结构 swiper普通使用： 123456789101112131415161718&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/css/swiper.min.css\"&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/js/swiper.js\"&gt;&lt;/script&gt;&lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt;Slide 1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 2&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 3&lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=\"swiper-button-prev\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=\"swiper-scrollbar\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920// 第三库实例化var mySwiper = new Swiper ('.swiper-container', { // direction: 'vertical', // 垂直切换选项 loop: true, // 循环模式选项 // 如果需要分页器 pagination: { el: '.swiper-pagination', }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, // 如果需要滚动条 scrollbar: { el: '.swiper-scrollbar', }, autoplay: true}) 在Vue中使用： 静态数据第三方库实例化放在 mounted中1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;Banner&gt;&lt;/Banner&gt;&lt;/div&gt;&lt;template id = \"banner\"&gt; &lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\" v-for = \"banner in banners\" :key = \"banner.id\" &gt; {{ banner.text}} &lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=\"swiper-button-prev\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=\"swiper-scrollbar\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//第三方库的实例化要求，必须真实dom已经存在Vue.component('Banner',{ template: '#banner', data () { return { banners: [ { id: 1, text: 'slider 1' }, { id: 2, text: 'slider 2' }, { id: 3, text: 'slider 3' } ] } }, beforeCreate () { }, created () { }, beforeMount () { }, mounted () { //静态数据的第三方实例化 // 第三库实例化 this.mySwiper = new Swiper ('.swiper-container', { // direction: 'vertical', // 垂直切换选项 loop: true, // 循环模式选项 // 如果需要分页器 pagination: { el: '.swiper-pagination', }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, // 如果需要滚动条 scrollbar: { el: '.swiper-scrollbar', }, autoplay: true }) }})new Vue({el: '#app'}) 动态数据第三方库实例化放在请求数据中加上异步执行函数中，因为放在updated中每次数据变动都会重新实例化，加上if判断单例也可以，但是要是有多个第三方库就比较繁琐了12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;Banner&gt;&lt;/Banner&gt;&lt;/div&gt;&lt;template id = \"banner\"&gt; &lt;div&gt; &lt;input type=\"text\" v-model = \"num\"&gt; &lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\" v-for = \"banner in banners\" :key = \"banner.id\" &gt; {{ banner.text}} &lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=\"swiper-button-prev\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=\"swiper-scrollbar\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/*第三方库的实例化要求，必须真实dom已经存在业务： 动态数据请求，然后进行第三方库实例化的优化理由： 将动态数据的第三方库实例化放在updated中是有弊端的，弊端是第三方库会重复实例化解决：1. 加判断条件 if( this.mySwiper ) return false2. 将实例化放到异步队列中去- 将实例化放在created的数据请求中，然后放在setTimeout中- vue提供了一个它认为是最好的方案： nextTick使用： Vue.nextTick this.$nextTicknextTick表示组件渲染结束之后这个方法才会调用最优解决方案： nextTick */ Vue.component('Banner',{ template: '#banner', data () { return { banners: null, num:100 } }, beforeCreate () { }, created () { //数据请求一般写在这里 fetch('./data.json') .then( res =&gt; res.json()) .then( data =&gt; { this.banners = data // setTimeout(()=&gt;{ // this.mySwiper = new Swiper ('.swiper-container', { // // direction: 'vertical', // 垂直切换选项 // loop: true, // 循环模式选项 // // 如果需要分页器 // pagination: { // el: '.swiper-pagination', // }, // // 如果需要前进后退按钮 // navigation: { // nextEl: '.swiper-button-next', // prevEl: '.swiper-button-prev', // }, // // 如果需要滚动条 // scrollbar: { // el: '.swiper-scrollbar', // }, // autoplay: true // }) // },0) this.$nextTick( () =&gt; { this.swiper = new Swiper('.swiper-container',{ loop: true, autoplay: true, pagination: { el: '.swiper-pagination', }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, // 如果需要滚动条 scrollbar: { el: '.swiper-scrollbar', } }) }) }) .catch( error =&gt; console.log( error )) }, beforeMount () { }, mounted () { //静态数据的第三方实例化 // 第三库实例化 }, updated () { console.log( 'updated') if( this.mySwiper ) return false } }) new Vue({ el: '#app'}) 自定义指令v-htmlv-textv-forv-ifv-else-ifv-elsev-showv-onv-bindv-model以上指令可能不够用户使用，所以vue给开发者提供了自定义指令的方式举例： 比如说 我想要有一个指令，来实现一个自动获得input焦点，或是一个轮播 。。。有两种自定义指令的使用形式： 全局定义 —- vue.directive() 1234567891011121314151617181920212223242526Vue.directive('focus',{ //指令的钩子函数 bind () { //只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 console.log( 'bind' ) }, inserted (el,binding,vNode,oldVnode) { el.focus() el.style.background = 'red' // el.innerHTML = \"&lt;h3&gt; 123 &lt;/h3&gt;\" // console.log('el',el) // console.log('binding',binding) console.log('vNode',vNode) // console.log('oldVnode',oldVnode) console.log( 'inserted' ) }, update () { console.log('update') }, componentUpdated () {{ console.log( 'componentUpdated ' ) }}, unbind () { //只调用一次，指令与元素解绑时调用。 console.log( 'unbind' ) }}) 局部定义directives: {} 12345678910111213141516171819202122232425262728new Vue({ el: '#app', directives: { // 指令的名称： 指令的配置 'focus': { inserted ( el,binding ) { console.log('binding',binding) // if( binding.) /* def: {inserted: ƒ} expression: \"'b'\" modifiers: {a: true} name: \"focus\" rawName: \"v-focus.a\" value: \"b\" */ el.value = binding.expression if( binding.modifiers.a ){ el.style.background = 'red'; }else{ el.style.background = 'blue'; } el.focus() } } }}) 指令的钩子函数 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用 （ 指令绑定的元素被删除 ）。 自定义指令钩子的参数 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"}]},{"title":"vue组件","date":"2019-06-24T11:33:14.878Z","path":"/posts/yhk10000/","text":"vue组件组件是什么​ 组件是html css js 等的一个聚合体 为什么要使用组件？ 组件化 将一个具备完整功能的项目的一部分进行多处使用 加快项目的进度 可以进行项目的复用 要想实现组件化，那么我们使用的这一部分就必须是完整的，我们把这个完整的整体就称之为组件 插件： index.html img css js 如果能将 html css js img 等多个部分放在一起，vue将这个聚合体的文件称之为，单文件组件（ xx.vue ） Vue 是构造器函数 Vue.extend() 是 vue用来扩展 vue功能（ 组件 ）的 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。 data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数 1&lt;div id=\"mount-point\"&gt;&lt;/div&gt; 12345678910111213// 创建构造器var Profile = Vue.extend({ template: '&lt;p&gt;{{firstName}} {{lastName}} aka {{alias}}&lt;/p&gt;', data: function () { return { firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' } }})// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount('#mount-point') 结果如下： 1&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt; Vue决定不进行 实例化 Vue.extend(),vue借鉴了react，react中组件是以标签的形式使用的， vue 决定组件要以标签的形式呈现 基础的组件创建为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。 为了符合 html / html5的规则，所以组件的标签化使用必须注册， 注册就是用来解析这个标签化的组件html未能识别的标签 组件使用前必须进行注册 一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝 命名： ​ 一个单词的大写： 注意不要和原生的h5标签重名，比如 header footer Header Footer ​ 小写带- ， 比如 header-title ​ 大驼峰： YaoHengkang 使用 ： yao-hengkang 1、全局注册12345var Hello = Vue.extend({ template: '&lt;div&gt; 这里是father组件 &lt;/div&gt;' }) //VueComponent( option )Vue.component( 'Father', Hello ) 因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。 2、局部注册在组件中用一个components的配置项目来表示 只能在注册的范围内使用，其他地方是不能使用的 123&lt;div id=\"app\"&gt; &lt;yao-hengkang&gt;&lt;/yao-hengkang&gt;&lt;/div&gt; 1234567891011var Hello = Vue.extend({ template: '&lt;div&gt; Hello world &lt;/div&gt;' }) new Vue({ el: '#app', components: { // key: value key是组件名称 value是组件配置项 'yao-hengkang': Hello } }) 3、简写：1234&lt;div id=\"app\"&gt; &lt;Father&gt;&lt;/Father&gt; &lt;yao-hengkang&gt;&lt;/yao-hengkang&gt;&lt;/div&gt; 12345678910111213Vue.component('Father',{ template: '&lt;div&gt; 这里是全局注册 &lt;/div&gt;' }) new Vue({ el: '#app', components: { 'YaoHengkang': { template: '&lt;div&gt; 这里是局部注册 &lt;/div&gt;' } } }) 4、组件的嵌套​ 父组件里面放子组件 —-》 类似于dom结构的父子级结构 ​ 将子组件以标签的形式放在父组件的模板中使用 ​ 切记，不要放在父组件的内容中 ​ 组件不仅可以用双标签表示，也可以使用单标签表示 12345678&lt;div id=\"app\"&gt; &lt;!-- 下面这种写法是错误的 --&gt; &lt;Father&gt; &lt;Son&gt;&lt;/Son&gt; &lt;/Father&gt; &lt;!-- 正确的应该是 --&gt; &lt;Father&gt;&lt;/Father&gt; &lt;/div&gt; 1234567891011Vue.component('Father',{ template: '&lt;div&gt; Father &lt;Son&gt;&lt;/Son&gt;&lt;/div&gt;' }) Vue.component('Son',{ template: '&lt;div&gt; son &lt;/div&gt;' }) new Vue({ el: '#app', }) 或 12345678910111213new Vue({ el: '#app', components: { 'Father': { template: '&lt;div&gt; father组件 &lt;Son /&gt;&lt;/div&gt;', components: { 'Son': { template: '&lt;div&gt; son组件 &lt;/div&gt;' } } } }}) 5、is规则 ul>li ol>li table>tr>td select>option ​ 如上直属父子级如果直接组件以标签化形式使用，那么就会出现bug ​ 解决： 使用is规则: 通过is属性来绑定一个组件 1234567Vue.component('Hello',{ template: '&lt;tr&gt; &lt;td&gt; 4 &lt;/td&gt; &lt;td&gt; 2 &lt;/td&gt;&lt;td&gt; 3 &lt;/td&gt;&lt;/tr&gt;' })new Vue({ el: '#app'}) 12345678910111213&lt;div id=\"app\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;!-- 会出bug ↓ --&gt; &lt;hello&gt;&lt;/hello&gt; &lt;!-- 通过is属性来绑定 ↓ --&gt; &lt;tr is = \"Hello\"&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; 6、template使用： 实例范围内使用 ​ template中的内容被当做一个整体了，并且template标签是不会解析到html结构中的 实例范围外使用 ​ 实例范围外template标签是不会被直接解析的 ​ 组件要想使用template使用，我们采用第二种 ​ 但是使用第二种template使用后，有个弊端，template标签结构会在html文件中显示 ​ 解决： 使用webpack、gulp等工具编译，要用vue提供的单文件组件 组件通信为什么要进行通信组件可以是一个具有独立功能的整体，但是当我们要将这些组件拼接在一起时，这些组件要建立联系，这个联系我们就称之为通信 组件通信的方式有以下几种1.父子组件通信使用props实现 在父组件的模板中用单项数据绑定的形式，绑定在子组件身上 &lt;Son :money = \"money\"/&gt; 在子组件的配置项中可以使用一个props配置项来接收这个数据，接收时props可以是一个数组； 1234567 Vue.component('Son',{ template: `&lt;div&gt; &lt;h3&gt; 这里是子组件 &lt;/h3&gt; &lt;/div&gt;` props:['money'] })​ 在子组件模板中，接收到的属性可以像全局对象一样直接使用&lt;p&gt; 父亲给了我 钱 &lt;/p&gt;问题：自定义属性的书写HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：money —-> moneymask-flag —-> maskFlag问题：data为什么要定义为一个函数 组件是一个独立的个体，那么它应该拥有自己的数据，这个数据应该是一个独立的数据 也就是说这个数据应该有独立作用域，也就是有一个独立的使用范围，这个范围就是这个组件内 js的最大特征是：函数式编程 ， 而函数恰好提供了独立作用域问题： 为什么data要有返回值？返回值还是一个对象？ 因为Vue是通过observer来观察data选项的，所有必须要有返回值 因为Vue要通过es5的Object.defineProperty属性对对象进行getter和setter设置 123&lt;div id=\"app\"&gt; &lt;Father&gt;&lt;/Father&gt;&lt;/div&gt; 1234567891011121314151617181920212223 Vue.component('Father',{ template: `&lt;div&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;hr&gt; &lt;son :money = \"money\"&gt;&lt;/son&gt; &lt;/div&gt;`, data(){ return { money:1000 } } }) Vue.component('Son',{ template: `&lt;div&gt; &lt;h3&gt; 这里是子组件 &lt;/h3&gt; &lt;p&gt; 父亲给了我 {{ money }} 钱 &lt;/p&gt; &lt;/div&gt;`props:['money'] }) new Vue({el: \"#app\", }) 2.子父组件通信自定义事件子父通信流程 在父组件的模板中，通过事件绑定的形式，绑定一个自定义事件在子组件身上 &lt;son @give='getHongBao'&gt;&lt;/son&gt; 在子组件的配置项methods中写一个事件处理程序，在事件处理程序中触发父组件绑定的自定义事件 1234567891011121314Vue.component('Son',{ template: '#son', data:()=&gt;{ return { money : 1000 } }, methods:{ giveHongBao(){ this.money++ this.$emit('give',this.money) } } }) 将子组件定义的事件处理程序 giveFather,绑定在子组件的按钮身上 123456&lt;template id=\"son\"&gt; &lt;div&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; &lt;button @click='giveHongBao'&gt;发红包&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516 &lt;div id=\"app\"&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt;&lt;template id=\"father\"&gt; &lt;div&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;p&gt;儿子给了我{{ money }}&lt;/p&gt; &lt;son @give='getHongBao'&gt;&lt;/son&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"son\"&gt; &lt;div&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; &lt;button @click='giveHongBao'&gt;发红包&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930 Vue.component('Father',{ template:'#father', data:function(){ return { money:0 } }, methods:{ getHongBao(val){ this.money = val ; } }})Vue.component('Son',{ template: '#son', data:()=&gt;{ return { money : 1000 } }, methods:{ giveHongBao(){ this.money++ this.$emit('give',this.money) } }})new Vue({ el:\"#app\"}) 3.非父子组件通信​ ref链:可以实现非父子组件间的通信，但是如果层级太深，就比较繁琐了 ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 先给子组件注册引用信息 &lt;boy ref='boy'&gt;&lt;/boy&gt; 父组件通过$refs获得子组件信息 this.n = this.$refs.boy.money 父组件通过属性将数据传递给子组件 &lt;girl ref='girl' :money=\"n\"&gt;&lt;/girl&gt; 子组件通过$attr或props获得值 this.$attrs.money 12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; &lt;template id=\"father\"&gt; &lt;div&gt; 这里是father &lt;button @click=\"look\"&gt;得到boy的money&lt;/button&gt; &lt;hr&gt; &lt;boy ref='boy'&gt;&lt;/boy&gt; &lt;hr&gt; &lt;girl ref='girl' :money=\"n\"&gt;&lt;/girl&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=\"boy\"&gt; &lt;div&gt; 这里是boy--- {{ money }} &lt;/div&gt; &lt;/template&gt; &lt;template id=\"girl\"&gt; &lt;div&gt; 这里是girl &lt;button @click=\"out\"&gt; 输出girl的money &lt;/button&gt; &lt;/div&gt; &lt;/template&gt; 1234567891011121314151617181920212223242526272829303132Vue.component('Father', { template: '#father', data() { return { n: 0 } }, methods: { look() { this.n = this.$refs.boy.money } } }) Vue.component('Boy', { template: '#boy', data() { return { money: 1000 } } }) Vue.component('Girl', { template: '#girl', methods: { out() { console.log(this.$attrs.money) } } }) new Vue({ el: \"#app\" }) ​ bus事件总线 新建vue实例bus ​ var bus = new Vue(); 在接收组件mounted()中声明事件 12345var _this = this bus.$on('da', function () { _this.flag = true console.log(this) //这里是this指的是bus， 但是我们需要的this应该是brother这个组件 }) 在发送消息中定义$emit触发事件 12345methods: { hick() { bus.$emit('da') } } 案例： 12345678910111213141516&lt;div id=\"app\"&gt; &lt;old-sister&gt;&lt;/old-sister&gt; &lt;brother&gt;&lt;/brother&gt; &lt;/div&gt; &lt;template id=\"old-sister\"&gt; &lt;div&gt; &lt;h3&gt; 这里是姐姐组件 &lt;/h3&gt; &lt;button @click=\"hick\"&gt; 揍弟弟 &lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=\"brother\"&gt; &lt;div&gt; &lt;h3&gt; 这里是弟弟组件 &lt;/h3&gt; &lt;p v-show=\"flag\"&gt; 呜呜呜呜呜呜呜呜呜uwuwuwuwu &lt;/p&gt; &lt;/div&gt; &lt;/template&gt; 1234567891011121314151617181920212223242526272829var bus = new Vue(); Vue.component('old-sister', { template: '#old-sister', methods: { hick() { bus.$emit('da') } } }) Vue.component('Brother', { template: '#brother', data() { return { flag: false } }, mounted() { //当前组件挂载结束，也就是我们可以在页面当中看到真实dom // mounted这个钩子函数的触发条件是组件创建时会自动触发 // 事件的声明 var _this = this bus.$on('da', function () { _this.flag = true console.log(this) //这里是this指的是bus， 但是我们需要的this应该是brother这个组件 }) } }) new Vue({ el: \"#app\" }) 非常规通信： 父组件将一个方法通过属性绑定的形式给了子组件，子组件先是通过props接收这个方法，再执行这个方法 MVVM框架是单向数据流，但是上面的方法违背了单项数据流 父组件传递一个 引用类型 给 子组件 子组件通过 props 接收 就会发现： 子组件修改这个数据的时候，父组件的数据也随之改变了 不推荐使用 ， 违背了单向数据流 mounted 类型：Function 详细： el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted 4.多组件状态共享（ 多个组件共用同一个数据 ） （ vuex ）​ vuex 自定义事件 自定义的 通过 $on 定义 $emit触发vm.$on( event, callback )参数： {string | Array&lt;string&gt;} event {Function} callback用法： 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。vm.$emit( eventName, […args] )参数： {string} eventName [...args]示例：12345vm.$on('test', function (msg) { console.log(msg)})vm.$emit('test', 'hi')// =&gt; \"hi\" 通过绑定在组件身上定义，通过 $emit触发 &lt;Son @aa = \"fn\"/&gt; 使用： 子父通信 动态组件 什么是动态组件？ 可以改变的组件 使用 通过 Vue 提供了一个 component + is 属性 动态组件指的就是 component这个组件 案例 123456&lt;div id=\"app\"&gt; &lt;button @click = \"change\"&gt; 切换 &lt;/button&gt; &lt;keep-alive include=\"\"&gt; &lt;component :is = \"type\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt; 123456789101112131415161718Vue.component('Aa',{ template: '&lt;div&gt; Aa &lt;/div&gt;' }) Vue.component('Bb',{ template: '&lt;div&gt; Bb &lt;/div&gt;' }) new Vue({ data: { type: 'Aa' }, methods: { change () { this.type = (this.type === 'Aa'?'Bb':'Aa') } } }).$mount('#app') Vue提供了一个叫做 keep-alive 的组件可以将我们的组件进行浏览器缓存，这样当我们切换组件时，就可以大大提高使用效率 keep-alive也可以以属性的形式呈现，但是我们如果搭配component的话，建议使用组件的形式 slot 插槽 作用/概念: 预先将将来要使用的内容进行保留 12345678910111213&lt;div id=\"app\"&gt; &lt;Hello&gt; &lt;div&gt; 这里是杭州 &lt;/div&gt; &lt;/Hello&gt; &lt;/div&gt; &lt;template id=\"hello\"&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;h3&gt;这里是hello&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; 1234567Vue.component('Hello',{ template: '#hello' }) new Vue({ el: '#app' }) 具名插槽： 给slot起个名字 通过solt属性和name对应插槽位置 12345678910111213&lt;div id=\"app\"&gt; &lt;Hello&gt; &lt;header slot = 'header'&gt; 这里是头部 &lt;/header&gt; &lt;footer slot = 'footer'&gt; 这里是底部 &lt;/footer&gt; &lt;/Hello&gt;&lt;/div&gt;&lt;template id=\"hello\"&gt; &lt;div&gt; &lt;slot name = \"header\"&gt;&lt;/slot&gt; &lt;h3&gt;这里是hello&lt;/h3&gt; &lt;slot name = \"footer\"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 1234567Vue.component('Hello',{ template: '#hello' }) new Vue({ el: '#app' }) 注意： 以上两种形式在 vue2.6以上被废弃 为什么要 用 v-slot指令来代替呢？ 经具名插槽和作用域插槽进行统一 要将这两个属性带有 vue的标志，并且符合vue两个最大的特性之一： 指令的概念 v-slot:123456789101112131415161718192021222324252627282930 &lt;div id=\"app\"&gt; &lt;Hello&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt; &lt;/Hello&gt;&lt;/div&gt;&lt;template id ='hello'&gt; &lt;div class=\"container\"&gt; &lt;header&gt; &lt;!-- 我们希望把页头放这里 --&gt; &lt;slot name = \"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 我们希望把主要内容放这里 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 我们希望把页脚放这里 --&gt; &lt;slot name = 'footer'&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt; 1234567Vue.component('Hello',{ template: '#hello' }) new Vue({ el: '#app' }) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"}]},{"title":"虚拟dom && diff算法 && key","date":"2019-06-24T11:18:34.861Z","path":"/posts/qw123/","text":"虚拟dom && diff算法 && key什么是虚拟dom,为什么要使用虚拟dom?1、它是一个Object对象模型，用来模拟真实dom节点结构的树形结构 DOM: 12345&lt;div class=\"box\"&gt; &lt;ul&gt; &lt;li&gt; yhk &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; vdom: 1234567891011121314151617var vdom = { tag: 'div', attr: { className: 'box' }, content: [ { tag: 'ul', content: [ { tag: 'li', content: 'yhk' } ] } ] } 可见DOM结构中的内容都对应在vdom中； 2、为什么要使用虚拟dom 因为直接去操作dom节点是非常耗费性能的； 这里可以参考：网页性能管理详解 虚拟dom的使用基本流程1、获取数据（ajax,fetch,axios） 1234var data = { id: 1, name: 'yhk' } 2、创建vdom vue通过jsx + render函数来创建vdom jsx即JavaScript + xml 12345&lt;div class = \"box\"&gt; &lt;ul&gt; &lt;li&gt; {{ data.name }} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 3、通过render函数解析jsx，将其转化成vdom结构 1234567891011121314151617var vdom = { tag: 'div', attr: { className: 'box' }, content: [ { tag: 'ul', content: [ { tag: 'li', content: data.name } ] } ] } 4、将vdom渲染成真实dom render函数 1234567891011121314render: function (createElement) { return createElement('div',{ 'class': { box: true }, }, [ createElement('ul',[createElement('li', domProps: { innerHTML: data.name },)]) ] )} ​ createElement函数参数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687> // @returns {VNode}> createElement(> // {String | Object | Function}> // 一个 HTML 标签名、组件选项对象，或者> // resolve 了上述任何一种的一个 async 函数。必填项。> 'div',> > // {Object}> // 一个与模板中属性对应的数据对象。可选。> {> //// 与 `v-bind:class` 的 API 相同，> // 接受一个字符串、对象或字符串和对象组成的数组> 'class': {> foo: true,> bar: false> },> // 与 `v-bind:style` 的 API 相同，> // 接受一个字符串、对象，或对象组成的数组> style: {> color: 'red',> fontSize: '14px'> },> // 普通的 HTML 特性> attrs: {> id: 'foo'> },> // 组件 prop> props: {> myProp: 'bar'> },> // DOM 属性> domProps: {> innerHTML: 'baz'> },> // 事件监听器在 `on` 属性内，> // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。> // 需要在处理函数中手动检查 keyCode。> on: {> click: this.clickHandler> },> // 仅用于组件，用于监听原生事件，而不是组件内部使用> // `vm.$emit` 触发的事件。> nativeOn: {> click: this.nativeClickHandler> },> // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`> // 赋值，因为 Vue 已经自动为你进行了同步。> directives: [> {> name: 'my-custom-directive',> value: '2',> expression: '1 + 1',> arg: 'foo',> modifiers: {> bar: true> }> }> ],> // 作用域插槽的格式为> // { name: props => VNode | Array }> scopedSlots: {> default: props => createElement('span', props.text)> },> // 如果组件是其它组件的子组件，需为插槽指定名称> slot: 'name-of-slot',> // 其它特殊顶层属性> key: 'myKey',> ref: 'myRef',> // 如果你在渲染函数中给多个元素都应用了相同的 ref 名，> // 那么 `$refs.myRef` 会变成一个数组。> refInFor: true> },> > // {String | Array}> // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，> // 也可以使用字符串来生成“文本虚拟节点”。可选。> [> '先写一些文字',> createElement('h1', '一则头条'),> createElement(MyComponent, {> props: {> someProp: 'foobar'> }> })> ]> )> 5、 数据更改了 1data.name = 'xiaoming' 生成新的vdom 1234567891011121314151617vdom = { tag: 'div', attr: { className: 'box' }, content: [ { tag: 'ul', content: [ { tag: 'li', content: data.name } ] } ]} 6、使用diff算法比对两次vdom,生成patch对象 diff算法是同级比较 ​ 给每一个层级打一个标记，这个标记是一个数字（ 这个数字就是 key ） 7、根据key将patch对象渲染到页面中改变的结构上，而其他没有改变的地方是不做任何修改的（ 虚拟dom的惰性原则 ） 什么是diff算法diff算法是比较两个文件的差异，并将两个文件不同之处，将这个不同之处生成一个补丁对象（patch） ​ diff算法来源后端 ​ 前端将其应用于虚拟dom的diff算法 ​ vue中将 虚拟dom的diff算法放在了 patch.js文件中 ​ 使用js来进行两个对象的比较（ vdom 对象模型） ​ diff算法是同级比较 ​ 给每一个层级打一个标记，这个标记是一个数字（ 这个数字就是 key ） vue是一是MVVM框架，Vue高性能的原因之一就是vdom keykey 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。 验证 key - 列表循环一定加key - key最好是使用具有唯一标识性的 id 案例： 以一个案例来说明key是用来做标识的（ 同级比较 ） 1234567891011&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for = \" (item,index) in list\" :key = \"item.id\"&gt; &lt;p&gt; {{ item.text }} &lt;/p&gt; &lt;div&gt; &lt;button @click = \"changeStyle\"&gt; 修改样式 &lt;/button&gt; &lt;button @click = \"remove( index )\"&gt;删除 &lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 12345678910111213141516171819202122232425new Vue({ el: '#app', data: { list: [ { id: 1, text: '敲代码1' }, { id: 2, text: '敲代码2' } ] }, methods: { changeStyle ( e ) { //这里是为了看key的作用，但是真实操作中不会用到， // 理由： 我们应该避免操作真实dom e.target.parentNode.parentNode.style.background = 'red' }, remove ( index ) { this.list.splice( index, 1 ) } } }) 尝试将key改为index或者不写，在将敲代码1改变样式并删除后，敲代码2的背景色变为了红色； document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"}]},{"title":"浅谈vue原理","date":"2019-06-22T02:04:45.165Z","path":"/posts/1a123/","text":"浅谈vue原理 数据驱动当数据发生改变时，视图也会进行更新，这叫做数据驱动，也就是数据驱动视图 深入响应式原理数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新 双向数据绑定原理当我们使用 v-model 指令绑定了表单元素时，那么我们可以在视图直接获得数据，当视图发生改变时，数据也会进行更新综上： 三者都是应用了同一个底层原理，这个底层原理由es5的 Object.defineProperty 属性来提供 Object.defineProperty(obj, prop, descriptor)该方法允许精确添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，能够在属性枚举期间呈现出来（for…in 或 Object.keys 方法）， 这些属性的值可以被改变，也可以被删除。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的。obj要在其上定义属性的对象。prop要定义或修改的属性的名称。descriptor将被定义或修改的属性描述符。返回值被传递给函数的对象。对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。数据描述符和存取描述符均具有以下可选键值(默认值是在使用Object.defineProperty()定义属性的情况下)：configurable当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。enumerable当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。数据描述符同时具有以下可选键值：value该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。writable当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。存取描述符同时具有以下可选键值：get一个给属性提供 getter 的方法，如果没有 getter 则为undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为undefined。 set一个给属性提供 setter的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。 12345678910111213141516var input = document.querySelector('input');var p = document.querySelector('p');var obj = { name: \"\", }Object.defineProperty(obj, \"name\", { get() { return \"你好\"; }, set(val) { p.innerHTML = val; } })input.oninput = function () { obj.name= this.value;} vue中底层原理的实现主要是依赖 存储器（ getter/setter ） 我们利用了数据劫持和事件的发布订阅来实现双向数据绑定，当我们在vue data选项中定义数据时，vue会通过观察者对象（ observer ）将data选项中的所有key，经过Object.defineProperty 的getter 和setter进行设置，当我们通过 v-model指令绑定元素是， 自动触发getter,getter会返回一个初始值，这样我们在视图中就可以看到数据了，当视图中内容改变时，会触发setter,setter会通知vue，视图已经进行了更新，vue会重新生成 虚拟DOM , 继而通过 新旧 虚拟DOM 对比， 生成patch对象，再将patch对应渲染到视图中 Vue.set/this.$set 的原理（ 数组的下标和length不响应 ） 12var vm = new Vue({ data:{ a:1 } }) // `vm.a` 是响应式的 vm.b = 2 // `vm.b` 是非响应式的 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用Vue.set(object, propertyName, value)方法向嵌套对象添加响应式属性。例如： 1Vue.set(vm.someObject, 'b', 2) 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set方法的别名： 1this.$set(this.someObject,'b',2) 有时你可能需要为已有对象赋值多个新属性，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。 12// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 }) Object.assign()： 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 12345678910const target = { a: 1, b: 2 };const source = { b: 4, c: 5 };const returnedTarget = Object.assign(target, source);console.log(target);// expected output: Object { a: 1, b: 4, c: 5 }console.log(returnedTarget);// expected output: Object { a: 1, b: 4, c: 5 } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"}]},{"title":"框架级的数据请求","date":"2019-06-22T01:44:14.166Z","path":"/posts/1/","text":"框架级的数据请求1. axios(第三方库)axios get: 12345678&lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;button @click=\"getMData\"&gt;get - mock - json&lt;/button&gt; &lt;button @click=\"getOnLineData\"&gt;get - backend online- api&lt;/button&gt; &lt;button @click=\"getMPhpData\"&gt;get - myself - php -api&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950new Vue({ el: \"#app\", methods: { getMData() { axios({ url: \"../data/data.json\", method: \"GET\" }) .then(res => { console.log(res) }) .catch(error => conosle.log(error)) }, getOnLineData() { axios({ url: \"https://m.maizuo.com/gateway\", method: \"GET\", params: { 'cityId': 440100, 'pageNum': 1, 'pageSize': 20, 'type': 1, 'k': 6848113, }, headers: { 'X-Client-Info': '{\"a\":\"3000\",\"ch\":\"1002\",\"v\":\"5.0.4\",\"e\":\"15610873798997956485756\"}', 'X-Host': 'mall.film-ticket.film.list' } }) .then(res => { console.log(res) }) .catch(error => conosle.log(error)) }, getMPhpData() { axios({ url: 'http://localhost:8080/get.php', method: 'GET', params: { a: 1, b: 2 } }) .then(res => { console.log(res) }) .catch(error => conosle.log(error)) } }}) axios post:123456789101112131415161718192021222324252627282930new Vue({ el: \"#app\", methods: { postData() { var params = new URLSearchParams() //得到params对象，用来接收参数 // params.append( key, value ) key就是参数名，value就是参数值 params.append('a', 2) params.append('b', 2) axios({ url: \"http://localhost:8080/post.php\", method: \"POST\", // data:{ // a:2, // b:2 // }后台不能正常接收数据，要处理未处理的数据才能返回 data: params, headers: { 'Content-Type': \"application/x-www-form-urlencoded\" //请求头设置为表单提交的请求头 } }) .then(res => { console.log(res) }) .catch(err => { console.log(err) }) } }}) 2. fetch ( javascript 原生提供 )fetch是原生javascript提供的 ， 所以它 可以当做全局变量使用 ，它是挂载在window对象身上的 fetch get&post: 1234&lt;div id=\"app\"&gt; &lt;button @click=\"getData\"&gt; get &lt;/button&gt; &lt;button @click=\"postData\"&gt; post &lt;/button&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839new Vue({ el: '#app', methods: { getData() { fetch('http://localhost:8080/get.php?a=1&b=2', { method: 'GET', }).then(res => res.json())//对数据进行格式化 .then((data) => { console.log(data) }) .catch(err => { console.log(err) }) }, postData() { fetch('http://localhost:8080/post.php', { method: 'POST', // mode: 'cors', // headers: { // 'content-type': 'application/json' // }, // body:JSON.stringify({a:1,b:2})//MDN中案例，无效 headers: new Headers({ 'Content-Type': 'application/x-www-form-urlencoded' // 指定提交方式为表单提交 }), body: new URLSearchParams([ [\"a\", 1], [\"b\", 2] ]).toString() }).then(res => res.json()) .then((data) => { console.log(data) }) .catch(err => { console.log(err) }) } }}) fetch要手动进行一次数据格式化，但是axios是内部进行了数据的格式化 fetch get 方法请求数据，参数要直接连接在url上 fetch 格式化数据 有三种 处理方法 .json() 格式化 json 类型数据， 将 json类型 string 转换成 json 对象 .text() 格式化文本 .blob() 格式化二进制数据 fetch 如果按照官网文档书写post请求，也有坑， 携带数据出现了问题 fetch post处理 设置请求头 通过 new URLSearchPrams 来携带参数 查看更多在MDN 3. vue这边的数据请求的发展 vue-resource ( Vue 以前自己封装使用的请求类库 ) ，但是 vue-resource作者已经放弃更新了 vue-resource 作者推荐我们使用 axios vue-resource 用法 和 axios 相似度 90% + vue2.0我们基本上使用的都是 fetch / axios vue-resource 是有jsonp的 vue-resource 如果在vue中使用，是挂载当前的 实例（ 组件 ） 的$http属性身上的 举例 this.$http( options ) this.$http.get() this.$http.post vue-resource 下载安装引入 vue1.x 推荐 支持jsonp使用: 返回的是promise对象 this.$http.get('url地址?key=value&key=value').then(succFN,errorFn) this.$http.get('url地址',{配置}).then(succFN,errorFn) this.$http.post('url地址',{数据},{配置}).then(succFN,errorFn) this.$http.jsonp('url地址',{配置}).then(succFN,errorFn) params:{ //携带参数 wd:'bulala' }, jsonp:'cb', //约束回调函数的key, jsonpCallback:'show',//回调函数名 请求: body: post需要携带的数据 支持string a=1&b=2 对象 URLSearchParams 类型 new Xxx() -> x.set(key,value) params: {key:value} 携带数据 get headers: {} 携带请求头 method：’get’ get/post/….. string timeout: number 超时 progress：fn 进度 credentials: false 是否携带跨源凭证 emulateJSON：true post请求是需要携带的请求头 jsonp:’回调函数键’ 默认是callback响应： body 返回的数据 对象 (JSONP.parse) bodyText 返回的数据 文本格式 toString axios 下载安装引入 vue2.x只有推荐 支持jsonp ?? axios({ url: 地址 method: 提交方法 get/post/put…….. params: get提交参数 data: post提交参数 参数==URLSearchParams new URLSearchParams().set(key,value) timeout:超时间 headers： 请求头})拦截器 interceptor在 then 和 catch 之前我们想做的事 axios 下载安装引入 vue2.x推荐希望可以this.$http 去使用axios，需要 配置: Vue.prototype.$http=axios; this.$http|axios({配置}).then(成功回调(res)).catch(失败回调(res))this.$http|axios.get(url,{配置}).then(成功回调(res)).catch(失败回调(res))this.$http|axios.post(url,pollfill).then(成功回调(res)).catch(失败回调(res)) post请求: pollfill = new URLSearchParams() -> params.append(‘a’, 111); this.$http|axios.post(url,pollfill).then(成功回调(res)).catch(失败回调(res)) this.$http|axios({ url:'', method:'post', data:pollfill })配置: url:’’ 地址 method: ‘’ 提交姿势 params：{} get提交的数据 data:{} post提交数据res: data: 数据 4. axios 和 fetch 没有jsonp 数据请求类型的 axios 和 fetch 都是promise axios会对我们请求来的结果进行再一次的封装（ 让安全性提高 ） ajax和axios、fetch的区别 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"},{"name":"数据请求","slug":"数据请求","permalink":"https://yhk15978.github.io/tags/数据请求/"}]},{"title":"npm scripts  npm脚本","date":"2019-06-21T12:38:25.690Z","path":"/posts/4a17b235/","text":"转载自：阮一峰http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html 一、什么是 npm 脚本？npm 允许在package.json文件里面，使用scripts字段定义脚本命令。 12345{// ...\"scripts\": {\"build\": \"node build.js\"}} 上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。 命令行下使用npm run命令，就可以执行这段脚本。 123$ npm run build# 等同于执行$ node build.js 这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多。 123项目的相关脚本，可以集中在一个地方。不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。可以利用 npm 提供的很多辅助功能。 查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。 1$ npm run 二、原理npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。 比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。 这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有Mocha，只要直接写mocha test就可以了。 1\"test\": \"mocha test\" 而不用写成下面这样。 1\"test\": \"./node_modules/.bin/mocha test\" 由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。 三、通配符由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。 12\"lint\": \"jshint *.js\"\"lint\": \"jshint **/*.js\" 上面代码中，*表示任意文件名，**表示任意一层子目录。如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。 1\"test\": \"tap test/\\*.js\" 四、传参向 npm 脚本传入参数，要使用--标明 1\"lint\": \"jshint **.js\" 向上面的npm run lint命令传入参数，必须写成下面这样。 1$ npm run lint -- --reporter checkstyle > checkstyle.xml 也可以在package.json里面再封装一个命令。 12\"lint\": \"jshint **.js\",\"lint:checkstyle\": \"npm run lint -- --reporter checkstyle > checkstyle.xml\" 五、执行顺序如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。如果是并行执行（即同时的平行执行），可以使用&符号。 1$ npm run script1.js & npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号。 1$ npm run script1.js && npm run script2.js 这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。 六、默认值一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。 12\"start\":\"node sever.js\",\"install\":\"node-gyp rebuild\" 上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。 七、钩子npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。 123\"prebuild\": \"echo I run before the build script\",\"build\": \"cross-env NODE_ENV=production webpack\",\"postbuild\": \"echo I run after the build script\" 用户执行npm run build的时候，会自动按照下面的顺序执行。 1npm run prebuild && npm run build && npm run postbuild 因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。 123\"clean\": \"rimraf ./dist && mkdir dist\",\"prebuild\": \"npm run clean\",\"build\": \"cross-env NODE_ENV=production webpack\" npm 默认提供下面这些钩子 prepublish，postpublish preinstall，postinstallpreuninstall， postuninstallpreversion，postversionpretest posttestprestop，poststopprestart， poststartprerestart，postrestart 自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。 12345678910const TARGET = process.env.npm_lifecycle_event;if (TARGET === 'test') { console.log(`Running the test task!`);}if (TARGET === 'pretest') { console.log(`Running the pretest task!`);}if (TARGET === 'posttest') { console.log(`Running the posttest task!`);} 注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。 八、简写形式四个常用的 npm 脚本有简写形式。 npm start是npm run start npm stop是npm run stop的简写 npm test是npm run test的简写 npm restart是npm run stop && npm run restart && npm run start的简写 npm start、npm stop和npm restart都比较好理解，而npm restart是一个复合命令，实际上会执行三个脚本命令：stop、restart、start。具体的执行顺序如下。 prerestart prestop stop poststop restart prestart start poststart postrestart 九、变量npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。首先，通过npm_package_前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。 123456{ \"name\": \"foo\", \"version\": \"1.2.5\", \"scripts\": { \"view\": \"node view.js\" }} 那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。 123// view.jsconsole.log(process.env.npm_package_name); // fooconsole.log(process.env.npm_package_version); // 1.2.5 上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是 Bash 脚本，可以用$npm_package_name和$npm_package_version取到这两个值。 npm_package_前缀也支持嵌套的package.json字段。 1234567\"repository\": { \"type\": \"git\", \"url\": \"xxx\" }, scripts: { \"view\": \"echo $npm_package_repository_type\" } 上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。下面是另外一个例子。 12\"scripts\": { \"install\": \"foo.js\"} 上面代码中，npm_package_scripts_install变量的值等于foo.js。 然后，npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。 1\"view\": \"echo $npm_config_tag\", 注意，package.json里面的config对象，可以被环境变量覆盖。 1234{ \"name\" : \"foo\", \"config\" : { \"port\" : \"8080\" }, \"scripts\" : { \"start\" : \"node server.js\" }} 上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。 1$ npm config set foo:port 80 最后，env命令可以列出所有环境变量。 1\"env\": \"env\" 十、常用脚本示例123456789101112131415161718// 删除目录\"clean\": \"rimraf dist/*\",// 本地搭建一个 HTTP 服务\"serve\": \"http-server -p 9090 dist/\",// 打开浏览器\"open:dev\": \"opener http://localhost:9090\",// 实时刷新 \"livereload\": \"live-reload --port 9091 dist/\",// 构建 HTML 文件\"build:html\": \"jade index.jade > dist/index.html\",// 只要 CSS 文件有变动，就重新执行构建\"watch:css\": \"watch 'npm run build:css' assets/styles/\",// 只要 HTML 文件有变动，就重新执行构建\"watch:html\": \"watch 'npm run build:html' assets/html\",// 部署到 Amazon S3\"deploy:prod\": \"s3-cli sync ./dist/ s3://example-com/prod-site/\",// 构建 favicon\"build:favicon\": \"node scripts/favicon.js\", 十一、 npm scripts npm脚本 明白为什么要使用npm脚本 集中存储当前项目的所有脚本命令 npm脚本使用 npm run xxx npm多脚本执行 npm run xxx & npm run xxx npm run xxx && npm run xxx npm脚本可以简写，但是仅限一下几个npm startnpm stopnpm testnpm restart 1234567891011121314151617181920{\"name\": \"scripts\",\"version\": \"1.0.0\",\"description\": \"\",\"main\": \"index.js\",\"scripts\": {\"pretest\": \"echo pretest\",\"test\": \"echo test\",\"posttest\": \"echo posttest\",\"dev\": \"node server.js\",\"build\": \"npm run dev\",\"app\": \"node app.js\",\"yyb\": \"npm run app&npm run dev\",\"junge\": \"npm run app&&npm run dev\",\"env\": \"env\"},\"keywords\": [],\"author\": \"\",\"license\": \"ISC\"} 十一、参考链接* http://www.ruanyifeng.com/blog/2016/10/npm_scripts.htmlby ruanyifeng document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"}]},{"title":"Node.js 常用模块","date":"2019-06-21T12:26:48.145Z","path":"/posts/4a17b109/","text":"Node.js 常用模块URL url.parse(urlString[, parseQueryString[, slashesDenoteHost]]) 将url字符转成url对象 urlString 要解析的 URL 字符串。 parseQueryString 如果设为 true，则返回的 URL 对象的 query 属性会是一个使用 querystring 模块的 parse() 生成的对象。 如果设为 false，则 query 会是一个未解析未解码的字符串。 默认为 false。 slashesDenoteHost 如果设为 true，则 // 之后至下一个 / 之前的字符串会解析作为 host。 例如， //foo/bar 会解析为 {host: 'foo', pathname: '/bar'} 而不是 {pathname: '//foo/bar'}。 默认为 false。 url.format(URL[, options])将url对象转成url字符 URL 一个对象 options auth 如果序列化的URL字符串应该包含用户名和密码为true，否则为false。默认为true。 fragment 如果序列化的URL字符串应该包含分段为true，否则为false。默认为true。 search如果序列化的URL字符串应该包含搜索查询为true，否则为false。默认为true。 unicode true 如果出现在URL字符串主机元素里的Unicode字符应该被直接编码而不是使用Punycode编码为true，默认为false。 3.url.resolve(from, to)url路径的拼接，替换 from 解析时相对的基本 URL。 to要解析的超链接 URL。 例子：1234const url = require('url');url.resolve('/one/two/three', 'four'); // '/one/two/four'url.resolve('http://example.com/', '/one'); // 'http://example.com/one'url.resolve('http://example.com/one', '/two'); // 'http://example.com/two' querystring（查询字符串） querystring.stringify(obj[, sep[, eq[, options]]])解析对象部分转成URLsearch obj 要序列化为 URL 查询字符串的对象。 sep用于在查询字符串中分隔键值对的子字符串。默认值: '&'。 eq 用于在查询字符串中分隔键和值的子字符串。默认值: '='。 options encodeURIComponent 在查询字符串中将 URL 不安全字符转换为百分比编码时使用的函数。默认值: querystring.escape()。 querystring.stringify() 方法通过迭代对象的自身属性从给定的 obj 生成 URL 查询字符串1234querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });// 返回 'foo=bar&baz=qux&baz=quux&corge='querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');// 返回 'foo:bar;baz:qux' 默认情况下，查询字符串中需要百分比编码的字符将编码为 UTF-8。 如果需要其他编码，则需要指定其他 encodeURIComponent 选项： 123// 假设 gbkEncodeURIComponent 函数已存在。querystring.stringify({ w: '中文', foo: 'bar' }, null, null,{ encodeURIComponent: gbkEncodeURIComponent }); querystring.parse(str[, sep[, eq[, options]]]) 解析URLsearch部分转成对象 str 要解析的 URL 查询字符串。 sep 用于在查询字符串中分隔键值对的子字符串。默认值: '&'。 eq用于在查询字符串中分隔键和值的子字符串。默认值: '='。 options decodeURIComponent解码查询字符串中的百分比编码字符时使用的函数。默认值: querystring.unescape()。 maxKeys 指定要解析的键的最大数量。指定 0 可移除键的计数限制。默认值: 1000。 querystring.parse() 方法将 URL 查询字符串 str 解析为键值对的集合。例如，查询字符串 'foo=bar&abc=xyz&abc=123' 被解析为：1234{foo: 'bar',abc: ['xyz', '123']} querystring.parse() 方法返回的对象不是原型继承自 JavaScript Object。 这意味着典型的 Object 方法如 obj.toString()、 obj.hasOwnProperty() 等都没有定义并且不起作用。默认情况下，将假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他字符编码，则需要指定其他 decodeURIComponent 选项： 123// 假设 gbkDecodeURIComponent 函数已存在。querystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null,{ decodeURIComponent: gbkDecodeURIComponent }); querystring.escape(str) 可以将中文转成url百分比编码 strquerystring.escape() 方法以对 URL 查询字符串的特定要求进行了优化的方式对给定的 str 执行 URL 百分比编码。querystring.escape() 方法由 querystring.stringify() 使用，通常不会直接使用。 它的导出主要是为了允许应用程序代码在必要时通过将 querystring.escape 指定给替代函数来提供替换的百分比编码实现。 querystring.unescape(str)可以将url百分比编码解码 strquerystring.unescape() 方法在给定的 str 上执行 URL 百分比编码字符的解码。querystring.unescape() 方法由 querystring.parse() 使用，通常不会直接使用它。 它的导出主要是为了允许应用程序代码在必要时通过将 querystring.unescape 分配给替代函数来提供替换的解码实现。默认情况下， querystring.unescape() 方法将尝试使用 JavaScript 内置的 decodeURIComponent() 方法进行解码。 如果失败，将使用更安全的不会丢失格式错误的 URL 的等价方法。http模块 http.get(options[, callback])http.get(url[,options][, callback]) url string| url options 接受与 http.request() 相同的 options，且 method 始终设置为 GET。从原型继承的属性将被忽略。 callbackFunction 返回:http.ClientRequest由于大多数请求都是没有主体的 GET 请求，因此 Node.js 提供了这个便捷的方法。 这个方法与 http.request() 的唯一区别是它将方法设置为 GET 并自动调用 req.end()。 注意，由于 http.ClientRequest 章节中所述的原因，回调必须注意消费响应数据。callback 调用时只有一个参数，该参数是 http.IncomingMessage 的实例。获取 JSON 的示例：12345678910111213141516171819202122232425262728293031http.get('http://nodejs.cn/index.json', (res) => {const { statusCode } = res;const contentType = res.headers['content-type'];let error;if (statusCode !== 200) {error = new Error('请求失败\\n' +`状态码: ${statusCode}`);} else if (!/^application\\/json/.test(contentType)) {error = new Error('无效的 content-type.\\n' +`期望的是 application/json 但接收到的是 ${contentType}`);}if (error) {console.error(error.message);// 消费响应数据来释放内存。res.resume();return;}res.setEncoding('utf8');let rawData = '';res.on('data', (chunk) => { rawData += chunk; });res.on('end', () => {try {const parsedData = JSON.parse(rawData);console.log(parsedData);} catch (e) {console.error(e.message);}});}).on('error', (e) => {console.error(`出现错误: ${e.message}`);}); http.request(options[, callback]) http.request(url[, options][, callback]) url |url options Object protocol 使用的协议。默认值: 'http:'。 host 请求发送至的服务器的域名或 IP 地址。默认值: 'localhost'。 hostname host 的别名。为了支持 url.parse()，如果同时指定 host 和 hostname，则使用 hostname。 family number当解析 host 或 hostname 时使用的 IP 地址族。有效值为 4 或 6。如果没有指定，则同时使用 IP v4 和 v6。 port number远程服务器的端口。默认值: 80。 localAddress 为网络连接绑定的本地接口。 socketPath Unix 域套接字。如果指定了 host 或 port 之一（它们指定了 TCP 套接字），则不能使用此选项。 method 一个字符串，指定 HTTP 请求的方法。默认值: 'GET'。 path 请求的路径。应包括查询字符串（如果有）。例如 '/index.html?page=12'。当请求的路径包含非法的字符时，则抛出异常。目前只有空格被拒绝，但未来可能会有所变化。默认值: '/'。 headersObject 包含请求头的对象。 auth 基本的身份验证，即 'user:password'，用于计算授权请求头。 agent | 控制 Agent 的行为。可能的值有： undefined (默认): 对此主机和端口使用 http.globalAgent。 Agent 对象: 显式地使用传入的 Agent。 false: 使用新建的具有默认值的 Agent。 createConnection 当 agent 选项未被使用时，用来为请求生成套接字或流的函数。这可用于避免创建自定义的 Agent 类以覆盖默认的 createConnection 函数。详见 agent.createConnection()。任何双工流都是有效的返回值。 timeout: 指定套接字超时的数值，以毫秒为单位。这会在套接字被连接之前设置超时。 setHost : 指定是否自动添加 Host 请求头。默认值: true。 callback 返回: Node.js 为每个服务器维护多个连接以发出 HTTP 请求。 此函数允许显式地发出请求。url 可以是字符串或 URL 对象。 如果 url 是一个字符串，则会自动使用 url.parse() 解析它。 如果它是一个 URL 对象，则会自动转换为普通的 options 对象。如果同时指定了 url 和 options，则对象会被合并，其中 options 属性优先。可选的 callback 参数会作为单次监听器被添加到 'response' 事件。http.request() 返回 http.ClientRequest 类的实例。 ClientRequest 实例是一个可写流。 如果需要使用 POST 请求上传文件，则写入到 ClientRequest 对象。123456789101112131415161718192021222324252627282930const postData = querystring.stringify({'msg': '你好世界'});const options = {hostname: 'nodejs.cn',port: 80,path: '/upload',method: 'POST',headers: {'Content-Type': 'application/x-www-form-urlencoded','Content-Length': Buffer.byteLength(postData)}};const req = http.request(options, (res) => {console.log(`状态码: ${res.statusCode}`);console.log(`响应头: ${JSON.stringify(res.headers)}`);res.setEncoding('utf8');res.on('data', (chunk) => {console.log(`响应主体: ${chunk}`);});res.on('end', () => {console.log('响应中已无数据');});});req.on('error', (e) => {console.error(`请求遇到问题: ${e.message}`);});// 将数据写入请求主体。req.write(postData);req.end(); 注意，在示例中调用了 req.end()。 使用 http.request() 时，必须始终调用 req.end() 来表示请求的结束，即使没有数据被写入请求主体。如果在请求期间遇到任何错误（DNS 解析错误、TCP 层的错误、或实际的 HTTP 解析错误），则会在返回的请求对象上触发 'error' 事件。 与所有 'error' 事件一样，如果没有注册监听器，则会抛出错误。以下是需要注意的一些特殊的请求头。 发送 'Connection: keep-alive' 会通知 Node.js 与服务器的连接应该持续到下一个请求。 发送 'Content-Length' 请求头会禁用默认的分块编码。 发送 'Expect' 请求头会立即发送请求头。通常情况下，当发送 'Expect: 100-continue' 时，应设置超时时间和 'continue' 事件的监听器。详见 RFC2616 的第 8.2.3 节。 发送授权请求头会使用 auth 选项覆盖以计算基本的身份验证。使用 URL 作为 options 的示例：1234const options = new URL('http://abc:xyz@nodejs.cn');const req = http.request(options, (res) => {// ...}); 在成功的请求中，会按以下顺序触发以下事件： 'socket' 事件 'response' 事件 res 对象上任意次数的 'data' 事件（如果响应主体为空，则根本不会触发 'data' 事件，例如在大多数重定向中） res 对象上的 'end' 事件 'close' 事件如果出现连接错误，则触发以下事件： 'socket' 事件 'error' 事件 'close' 事件如果在连接成功之前调用 req.abort()，则按以下顺序触发以下事件： 'socket' 事件 (在这里调用 req.abort()) 'abort' 事件 'error' 事件并带上错误信息 'Error: socket hang up' 和错误码 'ECONNRESET' 'close' 事件如果在响应被接收之后调用 req.abort()，则按以下顺序触发以下事件： 'socket' 事件 'response' 事件 res 对象上任意次数的 'data' 事件 (在这里调用 req.abort()) 'abort' 事件 res 对象上的 'aborted' 事件 'close' 事件 res 对象上的 'end' 事件 res 对象上的 'close' 事件注意，设置 timeout 选项或使用 setTimeout() 函数不会中止请求或执行除添加 'timeout' 事件之外的任何操作。 http.createServer([options][, requestlistener]) 创建服务 options IncomingMessage 指定要使用的 IncomingMessage 类。用于扩展原始的 IncomingMessage。默认值:IncomingMessage。 ServerResponse 指定要使用的 ServerResponse 类。用于扩展原始 ServerResponse。默认值: ServerResponse。 requestListener 返回: 返回新建的 http.Server 实例。requestListener 是一个自动添加到 'request' 事件的函数。// server.listen 是开启监听// 第一个参数是port// 第二个参数可选 是回调server.listen(port, () => {console.log(server is running on ${port});}); 阿萨fs（文件系统） fs.readFile(path[, options], callback) 读取文件 path文件名或文件描述符。 options encoding 默认值: null。 flag 参阅支持的文件系统标志。默认值: 'r'。 callback err data异步地读取文件的全部内容。1234fs.readFile('/etc/passwd', (err, data) => {if (err) throw err;console.log(data);}); 回调会传入两个参数 (err, data)，其中 data 是文件的内容。如果没有指定 encoding，则返回原始的 buffer。如果 options 是字符串，则它指定字符编码： 1fs.readFile('/etc/passwd', 'utf8', callback); 当 path 是目录时， fs.readFile() 与 fs.readFileSync() 的行为是特定于平台的。 在 macOS、Linux 和 Windows 上，将返回错误。 在 FreeBSD 上，将返回目录内容的表示。 12345678// 在 macOS、Linux 和 Windows 上：fs.readFile('', (err, data) => {// => [Error: EISDIR: illegal operation on a directory, read ]});// 在 FreeBSD 上：fs.readFile('', (err, data) => {// => null, }); fs.readFile() 函数会缓冲整个文件。 为了最小化内存成本，尽可能通过 fs.createReadStream() 进行流式传输。 fs.writeFile(file, data[, options], callback) 写入文件 file | | | 文件名或文件描述符。 data | | | options | encoding | 默认值: 'utf8'。 mode 默认值: 0o666。 flag 参阅支持的文件系统标志。默认值: 'w'。 callback err 异步地将数据写入到一个文件，如果文件已存在则覆盖该文件。 data 可以是字符串或 buffer。如果 data 是一个 buffer，则 encoding 选项会被忽略。12345const data = new Uint8Array(Buffer.from('Node.js中文网'));fs.writeFile('文件.txt', data, (err) => {if (err) throw err;console.log('文件已被保存');}); 如果 options 是一个字符串，则它指定字符编码： 1fs.writeFile('文件.txt', 'Node.js中文网', 'utf8', callback); 在同一个文件上多次使用 fs.writeFile() 且不等待回调是不安全的。 对于这种情况，建议使用 fs.createWriteStream()。 文件描述符中英对照提交修改 任何指定的文件描述符都必须支持写入。 如果将文件描述符指定为 file，则不会自动关闭它。 写入将从文件的开头开始。例如，如果文件已经有内容 'Hello World‘ 并且新写入的内容是 'Aloha'，则该文件的内容将是 'Aloha World' 而不仅仅是 'Aloha'。 fs.rename(oldPath, newPath, callback) oldPath newPath callback err异步地将 oldPath 上的文件重命名为 newPath 提供的路径名。 如果 newPath 已存在，则覆盖它。 除了可能的异常，完成回调没有其他参数。也可参阅 rename(2)。1234fs.rename('旧文件.txt', '新文件.txt', (err) => {if (err) throw err;console.log('重命名完成');}); fs.readdir(path[, options], callback) path options encoding默认值: 'utf8'。 withFileTypes) 默认值: false。 callback err files异步的 readdir(3)。 读取目录的内容。 回调有两个参数 (err, files)，其中 files 是目录中的文件名的数组（不包括 '.' 和 '..'）。可选的 options 参数可以是指定编码的字符串，也可以是具有 encoding 属性的对象，该属性指定用于传给回调的文件名的字符编码。 如果 encoding 设置为 'buffer'，则返回的文件名是 Buffer 对象。如果 options.withFileTypes 设置为 true，则 files 数组将包含 fs.Dirent 对象。 fs.mkdir(path[, options], callback) path options recursive 默认值: false。 mode Windows 上不支持。默认值: 0o777。 callback err异步地创建目录。 除了可能的异常，完成回调没有其他参数。可选的 options 参数可以是指定模式（权限和粘滞位）的整数，也可以是具有 mode 属性和 recursive 属性（指示是否应创建父文件夹）的对象。1234// 创建 /tmp/a/apple 目录，无论是否存在 /tmp 和 /tmp/a 目录。fs.mkdir('/tmp/a/apple', { recursive: true }, (err) => {if (err) throw err;}); fs.copyFile(src, dest[, flags], callback) src要拷贝的源文件名。 dest拷贝操作的目标文件名。 flags用于拷贝操作的修饰符。默认值: 0。 callback异步地将 src 拷贝到 dest。 默认情况下，如果 dest 已经存在，则覆盖它。 除了可能的异常，回调函数没有其他参数。 Node.js 不保证拷贝操作的原子性。 如果在打开目标文件用于写入后发生错误，则 Node.js 将尝试删除目标文件。flags 是一个可选的整数，指定拷贝操作的行为。 可以创建由两个或更多个值按位或组成的掩码（比如 fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE）。 fs.constants.COPYFILE_EXCL - 如果 dest 已存在，则拷贝操作将失败。 fs.constants.COPYFILE_FICLONE - 拷贝操作将尝试创建写时拷贝（copy-on-write）链接。如果平台不支持写时拷贝，则使用后备的拷贝机制。 fs.constants.COPYFILE_FICLONE_FORCE - 拷贝操作将尝试创建写时拷贝链接。如果平台不支持写时拷贝，则拷贝操作将失败。123456const fs = require('fs');// 默认情况下将创建或覆盖目标文件。fs.copyFile('源文件.txt', '目标文件.txt', (err) => {if (err) throw err;console.log('源文件已拷贝到目标文件');}); 如果第三个参数是数字，则它指定 flags: 1234const fs = require('fs');const { COPYFILE_EXCL } = fs.constants;// 通过使用 COPYFILE_EXCL，如果目标文件存在，则操作将失败。fs.copyFile('源文件.txt', '目标文件.txt', COPYFILE_EXCL, callback); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"}]},{"title":"http爬虫和模块化","date":"2019-06-21T12:16:08.207Z","path":"/posts/4a117b12/","text":"http爬虫 和 模块化 http爬虫 12345678910111213141516171819202122232425262728293031323334const https = require(\"https\");const cheerio = require('cheerio');const req = https.get(\"https://www.17k.com/all\", (res) => { // res response 响应( 回馈 ) res.setEncoding('utf8'); // 得到结果的编码 let rawData = ''; res.on('data', (chunk) => { rawData += chunk; }); res.on('end', () => { try { //console.log(rawData) // html string const $ = cheerio.load(rawData) $('.td3 a').each(function(i, ele) { console.log($(this).text()) }) } catch (e) { console.error(e.message); } });}).on('error', (e) => { console.error(`Got error: ${e.message}`);});req.end() http web服务器渲染数据发送前台 1234567891011121314151617181920212223242526272829303132333435363738394041424344const https = require(\"https\");const http = require(\"http\");const cheerio = require('cheerio');const port = 8000;const host = 'localhost';const server = http.createServer(function(request, response) { response.writeHead(200, { 'Content-Type': 'text/html;charset=utf8' // 'Content-Type': 'text/html' }) const req = https.get(\"https://www.17k.com/all\", (res) => { // res response 响应( 回馈 ) res.setEncoding('utf8'); // 得到结果的编码 let rawData = ''; res.on('data', (chunk) => { rawData += chunk; }); res.on('end', () => { try { //console.log(rawData) // html string const $ = cheerio.load(rawData) $('.td3 a').each(function(i, ele) { response.write(`${ $(this).text() }`) }) response.end(); } catch (e) { console.error(e.message); } }); }).on('error', (e) => { console.error(`Got error: ${e.message}`); }); req.end()}).listen(port, host, function() { console.log(`http://${host}:${port}`)}) 中文乱码 123456789101112131415161718192021222324252627282930/* 服务器： 可以运行在服务端一个网站（站点） 种类： 1. web服务器（ 静态服务器 ） ，可以运行在浏览器中的服务器 2. api服务器 （ 后端接口 ） 后端语言暴露一个数据接口，用于前端数据请求（ ajax fetch ） Node.js中原生创建web服务器 http模块 createServer( callback ) 创建服务器 callback中接收三个参数 request response listen(port,host,callback) 监听服务器（ 反馈服务器状态 ） port 端口 host 域名 Node.js中中文乱码 1. 设置请求头 response.writeHead( 200, { 'Content-Type': 'text/html;charset=UTF8' // 小写也可以 utf8 }) 2. 发送一个meta标签 response.write('') 3. toString() 在当前应用场景中还不行 二进制有效 将二进制 --- 》 string 名词： chunk 分片 我们刚才发送了一个html给前台，那么这种渲染数据的形式我们称之为： ‘后端渲染’，也称之为：‘服务端渲染’，英文叫法： ‘ssr’*/ 2. 前端模块化 问题： 为什么前端要使用模块化？ 模块化： 是具有特定功能的一个对象（ 广义理解 ） 模块定义的流程： 1.定义模块（对象） 2.导出模块 3.引用模块 好处： 可以存储多个独立的功能块 复用性高 种类 AMD（ require.js） CMD ( sea.js ) Common.js AMD定义一个模块 define 1234567891011121314151617// AMD/* 目录 admDir a.js index.js*/// AMD定义 a.js define ({ a: 1, b: 2, add: function(){} })// AMD引用 index.js require([./a.js],function( moduleA ){ //moduleA指的就是定义来的对象 }) CMD定义模块 define 1234567891011121314151617//CMD/* 目录结构 b.js index.js*/// 模块定义 b.js define(function(require, exports, module) { // 模块代码 });//模块引用 index.js require('./b.js',function( moduleB ){ //moduleB就是b模块中导出的内容 }) Common.js Node.js使用了Common.js的规范 易错的理解： common.js是属于node的 × node属于common.js ×1234567891011121314//common.js/* 目录结构： name.js index.js*///模块的定义 name.js const nameObj = { name: 'Gabriel Yan ' }//模块的导出 name.js module.exports = nameObj//模块的引用 const nameObj = require('./name.js') Node.js中Common.js规范的使用有三种类型： 内置模块（ 内置模块指的是挂载在Node.js全局对象身上的api ） 自定义模块 模块的定义 123456//举例const student = { id: 1, name: 'Gabriel Yan'}const fn = function(){} 模块的导出 123456// 第一种导出module.exports = student // 安全性不高 默认导出一个//第二种导出module.exports = { //批量导出，按需引用 student,fn} 模块的引用 1234// 这种引用对应第一种导出const student = require('./xxx.js')// 这种引用对应第二种导出const { student , fn } = require( './xxx.js ' ) 注意： 在自定义模块引用时，require一定要写好路径 第三方模块 12345678910111. 别人已经封装好的模块2. 这个模块具备一些特定的功能3. 这些模块存放在 www.npmjs.com 这个网站中这些模块的文档也记录在内格式： var/let/const 变量名 = require( 模块名称 ) 总结： 第一步，使用npm/cnpm 安装 第二部，在文件中引入 第三部，在www.npmjs.com这个网站中找到这个模块的文档，根据文档来使用 思考： 我们是不是能将自己封装的自定义模块变成第三方模块？ 分析： 第三方模块具备的特性： 有一定的功能2. 存储在: http://www.npmjs.com 中 解决： 自定义模块的上传（ http://www.npmjs.com ） 创建package.json文件 1$ npm init -y 在http://www.npmjs.com 这个网站注册一个账号 注意：第一次登陆会发送一个邮件给你的邮箱（ 这个发送是手动的 ），然后大家登陆邮箱激活 检查你的电脑的源是不是npm源 1$ nrm ls 如果是，就不会理会 如果不是，那么切换到npm源 命令行登录npmjs仓库 1$ npm adduser 创建模块并导出模块 查看你的包名称是否已经被使用 发布包 1$ npm publish 犯错点： 邮箱没有激活 （ 最多的 ） npm源没有切换 整个电脑的npm就不能使用 -D === –save-dev 1234//举例cnpm i jquery -D === cnpm i jquery --save-dev // 开发环境下使用cnpm i jquery -S === cnpm i jquery --save // 生产环境下使用 ​ Node.js跨域 跨域； 前端跨域 jsonp 反向代理（ 创建一个虚拟后端服务器，让这个后端服务器帮助我们请求数据） 后端跨域 node php java 设置请求头 使用第三方的中间件（ cors ） 中间件： 就是具有一定功能的一个函数 前端模块化1. amd AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。 首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。 1234567891011121314151617/** 网页中引入require.js及main.js **//** main.js 入口文件/主模块 **/// 首先用config()指定各模块路径和引用名require.config({ baseUrl: \"js/lib\", paths: { \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", }});// 执行基本操作require([\"jquery\",\"underscore\"],function($,_){ // some code here});复制代码 引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。 12345678910111213141516171819202122232425262728// 定义math.js模块define(function () { var basicNum = 0; var add = function (x, y) { return x + y; }; return { add: add, basicNum :basicNum };});// 定义一个依赖underscore.js的模块define(['underscore'],function(_){ var classify = function(list){ _.countBy(list,function(num){ return num > 30 ? 'old' : 'young'; }) }; return { classify :classify };})// 引用模块，将模块放在[]内require(['jquery', 'math'],function($, math){ var sum = math.add(10,20); $(\"#sum\").html(sum);}); ​ 2. cmd- require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码： 1234567define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.foo() } }); CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。 123456789101112131415161718192021222324252627282930313233/** AMD写法 **/define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() } });/** CMD写法 **/define(function(require, exports, module) { var a = require('./a'); //在需要时申明 a.doSomething(); if (false) { var b = require('./b'); b.doSomething(); }});/** sea.js **/// 定义模块 math.jsdefine(function(require, exports, module) { var $ = require('jquery.js'); var add = function(a,b){ return a+b; } exports.add = add;});// 加载模块seajs.use(['math.js'], function(math){ var sum = math.add(1+2);});3.ES6 Module- ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。 123456789101112/** 定义模块 math.js **/var basicNum = 0;var add = function (a, b) { return a + b;};export { basicNum, add };/** 引用模块 **/import { basicNum, add } from './math';function test(ele) { ele.textContent = add(99 + basicNum);}​ ​ 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。 12345678/** export default **///定义输出export default { basicNum, add };//引入import math from './math';function test(ele) { ele.textContent = math.add(99 + math.basicNum);} ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。 4.ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"}]},{"title":"MongoDB","date":"2019-06-21T12:10:16.785Z","path":"/posts/0/","text":"MongoDBMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 常用命令1234567891011121314151617181920212223242526272829303132333435363738show dbs 查看数据库use dbname 创建数据库 如果不存在创建数据库，否则切换到数据库show collections 显示数据库集合1.添加数据 db.web.save({\"name\": \"meiejuna\"}) 创建了名称为 web 的名称，名 db.web.insert({\"name\": \"meijuna\"}) 插入相同的数据，sava 覆盖，insert 报错 2.删除数据 db.students.remove( {} ) 删除 students 集合下的所有数据 db.students.remove({\"name\": \"meijuna\" }) 删除 students 集合为 name 为 meijuna 的数据 db.students.drop() or db.runCommand({\"\"})删除 students 集合 db.runCommand( { dropDaatabase: 1 } ) 删除当前数据库 3.修改数据db.students.updata({\"name\": \"meijuna\"},set:{\"sex\":\"women\"}) 单行修改db.students.updata({\"name\": \"meijuna\"},{$set:{\"sex\":\"women\"}}, true, true) 多行修改 //{查找条件} , { 修改内容 } 匹配所有条件数据 修改所有匹配项4.查找数据 db.students.find() 查找 students 集合中的 所有 数据 db.students.findONe() 查找 students 集合中的 第一条 数据 db.students.find().pretty() 可视化查询 5.排序 db.students.find().sort({\"age\": 1}) 1 升 -1 降序6.截取db.students.find().skip(2) 下标为 2 开始截取db.students.find().limit(2) 截取 2 条数据7.筛选显示db.students.find({age:20},{_id:0,age:1,name:1}) 0,筛选的结果不显示，1筛选结果显示 SQL简介 关系型数据库 以行和列的形式存储数据，以便于用户理解。这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。 关系型数据库有：mySql oracle SqlServer Access *db2 * 等 NoSQL简介 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 非关系型数据库: MongoDB，Redis，HBase，*CouchDB * 等 非关系型数据库与关系型数据库区别关系型数据库的优势：1. 复杂查询 可以用SQL语句方便的在多个表之间做非常复杂的数据查询。 2. 事务支持 使得对于安全性能很高的数据访问要求得以实现。 非关系型数据库的优势：1. 性能 NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2. 可扩展性 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 MongoDB优点它的特点是高性能、易部署、易使用，存储数据非常方便。 主要功能特性有： 面向集合存储，易存储对象类型的数据。 模式自由。 支持动态查询。 支持完全索引，包含内部对象。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象（如视频等）。 自动处理碎片，以支持云计算层次的扩展性 支持RUBY，PYTHON，JAVA，C++，PHP等多种语言。 文件存储格式为BSON（一种JSON的扩展） #### BSON 存储格式BSON是一种类似json的二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，**如Date和BinData类型。 BSON有三个特点：轻量性、可遍历性、高效性。 非关系型数据库文件存储格式为 BSON（一种JSON的扩展）。 MongoDB下载与安装1. MongoDB下载：https://www.mongodb.com/download-center#community 2. 设置环境变量在环境变量窗口中一般有两个变量，一个是你当前所使用的用户独有的环境变量，另一个是所有用户都可以访问的系统变量。其实如果在你的电脑上你只使用一个用户的话，那么不管你修改的用户的环境变量还是系统变量，效果都是一样的。为了以防未来会新建其他用户，那么我建议你修改系统变量而不是某个用户独有的环境变量。 3. 测试连接 管理员身份运行 cmd 输入 mongo 启动 mongdb 服务 net start mongdb 关闭 mongdb 服务 net stop MongoDB 4. 安装可视化工具(Robo 3T)https://robomongo.org/download node 使用 MongoDB 连接 MongoDB 123456789101112131415//1. 下载 mongoose cnpm i mongoose -D //2. 引入 mongoose const mongoose = require( 'mongoose');//3. 连接 mongoose // 连接本地mongodb ，本机的ip 127.0.0.1，端口：27017 数据库：studentmongoose.connect(\"mongodb://127.0.0.1:27017/student\",function(err){ if(!err){ console.log(\"connected to Mongodb\"); //连接成功 }else{ throw err;//如果连接失败，则抛出异常 }}); 存储数据 Schema不仅定义了文档结构和使用性能，还可以有扩展插件、实例方法、静态方法、复合索引、文档生命周期钩子。 12345Schema ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力Model ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对Entity ： 由Model创建的实体，他的操作也会影响数据库 存储数据步骤：定义Schema (骨架) > 创建model（模型）> Entity实例化方法。 1234567891011121314151617181920212223242526272829const mongoose = require( 'mongoose');const Schema = mongoose.Schema;mongoose.connect( 'mongodb://127.0.0.1:27017/meijuna',(error) => { if ( error ) { throw error } else { console.log( 'database is connected~') }})const userSchema = new Schema({ //定义数据模型 username: String, password: String})//通过模式studentSchema 创建一个模型studentModel var studentModel = mongoose.model(\"students\",studentSchema );var instance1 = new studentModel (); instance1.name=\"tangyan\";instance1.age=\"18\";instance1.save(function(err){ //通过save方法保存 if (err) { console.log('保存失败'); return; } }); 查询数据 12345// 查userModel.find({}, ( error, result ) => { if ( error ) throw error console.log ( result )}) 修改数据 123456789101112131415userModel.find({ username: 'aaa'}, ( error, result) =>{ if (error) throw error const _id = result[0]._id userModel.findById(_id, ( error, doc ) => { // 修改 if (error ) throw error console.log( doc ); doc.username = \"meijuna\"; doc.save ( (error) => { throw error console.log(\"数据修改成功\") }) })}) 删除数据 1234567891011121314userModel.find({ username: 'aaa'}, ( error, result) =>{ if (error) throw error const _id = result[0]._id userModel.findById(_id, ( error, doc ) => { // 删除 if (error ) throw error doc.remove( (error) => { if (error) throw error console.log('数据删除成功！') }) })}) 注册 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const mongoose = require('mongoose');const Schema = mongoose.Schema;mongoose.connect('mongodb://127.0.0.1:27017/meijuna', (error) => { if (error) { throw error } else { console.log('database is connected !!!') }})const userSchema = new Schema({ //定义数据模型 username: String, password: String})const userModel = mongoose.model('users', userSchema) //模型创建const user = new userModel(); //创建实体router.get('/', (req, res, next) => { const { username, password } = req.query; console.log(username,password); userModel.find({}, (error, result) => { var flag = result.some((item) => { return item.username === username }) if (flag) { //用户名存在 res.render('register', { data: JSON.stringify({ ret: true, //身份验证 权限验证 status: 2 //0 表示失败 1：成功 2： }) }) } else { user.username = username; user.password = password; user.save(); res.render('register', { data: JSON.stringify({ ret : true, status: 1 }) }) } })}) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据库","slug":"数据库","permalink":"https://yhk15978.github.io/tags/数据库/"}]},{"title":"express Node 核心框架","date":"2019-06-21T12:02:11.085Z","path":"/posts/4a17b112/","text":"express Node 核心框架express是一个功能极简, 完全是由路由和中间件构成的一个web开发框架,是非侵入式的框架 1. 为什么要使用 express ?1234567- express 是 Node 的核心框架- express 可以帮助我们快速构建 web 服务器 / api 服务器- express 提供了一个快速生成工具 express-generator - 快速生成工具： 帮助我们快速创建一个项目的工具 2. 安装方式1. 全局安装123$ npm i express-generator -g or $ yarn add express-generator -g 2. npx 安装12345(如果npm版本在 5.2+，那可以不用全局，用npx)$ npx express -e express_demo -e : 指的是我们使用一个叫 ejs 的模板（ejs.js 可以兼容html标签, 可以在标签中写 js ） 3. 项目目录 bin www 启动了一个静态服务器 （ web服务器 ） node_modules 这个项目的依赖包 public 静态资源文件 ( html，css，images) routes 路由文件夹 view xxx.ejs （ 项目模板 ) app.js ( 这个项目的入口文件 ) 4. app.js 文件代码解读123456- app对象的功能 1. 通过app.use来使用具有特定功能的函数 ( 又叫中间件 )- 中间件分类 1. 应用中间件 （ cors ) 2. 路由中间件 app.get( '/' , (req, res, next ) => { } ) 3. 错误处理中间件 function( err, req, res, next ) { } 5. express 创建 api 服务器 （ 创建接口 ） api 服务器是给前端提供接口数据 api 服务器需要使用的给测试工具来测试，不能用浏览器展示 注意： 后端个前端发送的数据类型是 JSON 字符串，前端需要 JSON.parse() 转换成对象 6. restful api 规则restful aip 规则 是一个暴露接口的规则 ，实现是一个接口使用不同的数据请求方式来实现不同的功能总结： 使用restful api 来暴露接口（ 多个数据请求的接口 ） cors中间件的跨域 前端发来的数据， 后端如何接受 get req.query post req.body 7. 数据请求格式1. get 发送数据时，携带的参数时，形式是 Query string Parameters 后端 req.query 获取前端传来的数据 2. post 发送数据时，携带的参数时，形式是 Form Data 前端 req.body 获取前端传来的数据 8. ecj 模板ecj 官网 EJS 是一套简单的模板语言，帮你利用 JavaScript 代码生成 HTML 页面。 12345ejs模板语法: 执行正常js代码 转移输出 非转义输出 后端接口文档 ( 模板来写 )https://www.showdoc.cc/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"}]},{"title":"前端异步流程","date":"2019-06-21T11:20:20.187Z","path":"/posts/4a17b158/","text":"前端异步流程1. 传统的原生异步- 回调函数 - 事件2. 使用异步流程工具（ 别人封装好的东西 ）- es6 Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* Promise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise 所谓Promise ，简单说就是一个容器，里面保存着某个未来才回结束的事件(通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。 Promise 对象的状态不受外界影响 三种状态: pending：进行中 fulfilled :已经成功 rejected 已经失败 状态改变： Promise对象的状态改变，只有两种可能： 从pending变为fulfilled 从pending变为rejected。 这两种情况只要发生，状态就凝固了，不会再变了，这时就称为resolved（已定型）*/ const p1 = new Promise((resolve, reject) => { resolve('任务一') }).then(data => { console.log(data); return data; }) const p3 = new Promise((resolve, reject) => { setTimeout(() => { resolve('任务三') }, 1000) }).then(data => { console.log(data); return data; }) const p2 = new Promise((resolve, reject) => { setTimeout(() => { resolve('任务二') }, 2000) }).then(data => { console.log(data) return data }) console.log('主线程任务') //主线程任务 // all race // 如果作为参数的Promise实例自身定义了catch方法，那么它被rejected是并不会触发Promise.all()的catch方法 // Promise.all中都成功返回才执行 Promise.all([p1, p2, p3]).then(data => { //data为p1,p2,p3返回值组成的数组 console.log(data) //[ '任务一', '任务二', '任务三' ] }).catch(e => console.log(e)) // Promise.race中只要有一个成功返回就执行 Promise.race([p1, p2, p3]).then(data => { //data为p1,p2,p3中最先成功的返回值 console.log(data) //任务一 }) // 以上代码执行结果为 // 主线程任务 // 任务一 // 任务一 // 任务三 // 任务二 // [ '任务一', '任务二', '任务三' ] - es6 generator函数123456789101112131415161718192021/*generator函数在function关键字后面加一个* 这样定义的函数就叫做generator函数通过yield关键字来定义任务通过fn().next() 来执行任务value表示yield关键字后任务执行的结果done表示当前定义的所有的任务是否执行完成的一个状态理解：多任务的定义，多任务执行让自己定义的多个任务依次执行，上一个任务如果没有完成，下一个任务就不会开始*/function* fn() {yield '任务一'yield '任务二'return '任务'}const a = fn()console.log(a.next()) // { value: '任务一'，done: false }console.log(a.next()) //{ value: '任务二', done: false }console.log(a.next()) //{ value: '任务', done: true }console.log('主线程任务') //主线程任务 es6( 7 ) async 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*async函数es6提供配合关键字 await使用await 表示，等待，任务一执行结束之后，才会执行任务二async函数返回值为Promise对象*/async function fn() { const result = await '任务一' console.log(result) console.log('任务二')}fn()const fn1 = async() => {const res = await new Promise((res, rej) => { setTimeout(() => { res('任务3') }, 2000) }).then(result => { console.log(result) return result;})let req = await new Promise((res, rej) => { setTimeout(() => { res('任务四') }, 1000) }).then(result => { console.log(result) return result;}) console.log(req) console.log(res)if (false) { return req} else { throw res}//返回值通过then()调用，抛出值通过catch()调用}fn1().then(re => console.log(re)).catch(re => console.log(re))//结果:// 任务一// 任务二// 任务3// 任务四// 任务四// 任务3// 任务3 - node.js中的 nextTick setImmudiate 1234567nextTick()的回调函数执行的优先级要高于setImmediate();process.nextTick()属于idle观察者,setImmediate()属于check观察者.在每一轮循环检查中,idle观察者先于I/O观察者,I/O观察者先于check观察者.在具体实现上,process.nextTick()的回调函数保存在一个数组中,setImmediate()的结果则是保存在链表中.在行为上,process.nextTick()在每轮循环中会将数组中的回调函数全部执行完.而setImmediate()在每轮循环中执行链表中的一个回调函数.nextTick > 回调函数 > setImmediate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*Node.js提供的nextTicksetImmediate*///加入2个nextTick()的回调函数process.nextTick(function(){ console.log(\"nextTick延迟执行A\");});process.nextTick(function(){ console.log(\"nextTick延迟执行B\");setImmediate(function(){ console.log(\"setImmediate延迟执行C\");});process.nextTick(function(){ console.log(\"nextTick延迟执行D\");});});//加入两个setImmediate()回调函数setImmediate(function(){ console.log(\"setImmediate延迟执行E\");process.nextTick(function(){ console.log(\"强势插入F\");});setImmediate(function(){ console.log(\"setImmediate延迟执行G\");});});setImmediate(function(){ console.log(\"setImmediate延迟执行H\");process.nextTick(function(){ console.log(\"强势插入I\");});process.nextTick(function(){ console.log(\"强势插入J\");});setImmediate(function(){ console.log(\"setImmediate延迟执行K\");});});console.log(\"正常执行L\");// 正常执行L// nextTick延迟执行A// nextTick延迟执行B// nextTick延迟执行D// setImmediate延迟执行E// setImmediate延迟执行H// setImmediate延迟执行C// 强势插入F// 强势插入I// 强势插入J// setImmediate延迟执行G// setImmediate延迟执行K - 第三方的 async.js 库 12345678910111213141516171819202122232425262728293031323334353637383940414243/*async.js第三方的库案例：parallelseries功能：1. 可以实现异步2. 串行series和并行parallel*/const async = require( 'async' ) async.series({ one: function ( callback ) { setTimeout( function () { callback( null, 1)},200)},two: function ( callback ) {setTimeout( function () { callback ( null , 2 )},100)}}, function ( error , results ) { console.log( 'series',results )}) console.log( '主线程' )async.parallel({ one: function ( callback ) {setTimeout( function () { callback( null, 1)},200)},two: function ( callback ) { setTimeout( function () { callback ( null , 2 )},100)}}, function ( error , results ) { console.log( 'parallel',results )}) // 主线程// parallel { two: 2, one: 1 }// series { one: 1, two: 2 } 总结： 异步流程的任务是放在异步队列中的，异步队列只有在主线程执行完之后采取执行 参考资料 Promisehttps://blog.csdn.net/MrJavaweb/article/details/79475949 Generatorhttps://www.cnblogs.com/imwtr/p/5913294.html Async-await Node.js 中的nextTick()和setimmediate()https://www.cnblogs.com/5ishare/p/5268273.html async库https://caolan.github.io/async/参考文档Event-loophttp://www.ruanyifeng.com/blog/2014/10/event-loop.html?bsh_bid=983729729史上最易读懂的 Promise/A+ 完全实现https://zhuanlan.zhihu.com/p/21834559 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://yhk15978.github.io/tags/nodejs/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"}]},{"title":"vue基础语法","date":"2019-06-19T11:59:36.232Z","path":"/posts/4a17b157/","text":"vue基础语法mutache 语法糖123456&lt;div id=\"app\"&gt; &lt;p&gt; {{ this.msg }} &lt;/p&gt; &lt;p&gt; {{ this.$data.msg }} &lt;/p&gt; &lt;p&gt; {{ this._data.msg }} &lt;/p&gt; &lt;p&gt; {{ msg }} &lt;/p&gt;&lt;/div&gt; jsx: javascript + xml可以让我们在dom结构中输写javascript 是 this.msg 简写this.$data.msg -> this.msg -> msg mustache语法糖对数据类型的支持（ js语法的支持 ）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt; number: {{ num }} &lt;/p&gt; &lt;p&gt; string: {{ str }} &lt;/p&gt; &lt;p&gt; boolean: {{ bool }} &lt;/p&gt; &lt;p&gt; null: {{ nul?'1':'2' }} &lt;/p&gt; &lt;p&gt; undefined: {{ und && 1 || 2 }} &lt;/p&gt; &lt;p&gt; object: {{ obj.name }} &lt;/p&gt; &lt;p&gt; array: {{ arr[0] }} &lt;/p&gt; &lt;p&gt; fn: {{ fn() }} &lt;/p&gt; &lt;!-- &lt;p&gt; console.log: {{ console.log( 1 ) }} &lt;/p&gt; &lt;p&gt; alert: {{ alert( 2 ) }} &lt;/p&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; /* 数据类型： 第一种划分： 基础数据类型： number string boolean 复杂数据类型: Object( array function ) 特殊数据类型: null undefined 第二种划分： 初始数据类型: number string boolean null undefined 引用数据类型: object( array function ) 结论： mustache支持我们js的数据类型的 conosle.log 和 alert 在我们mustache语法中是不支持的 */var vm = new Vue({ el: '#app', data: { num: 100, str: 'hello Vue.js', bool: true, nul: null, und: undefined, obj: { name: 'yhk' }, arr: [1,2,3,4], fn: function () { alert( 2 ) return '这是一个函数' } }})&lt;/script&gt; mustache 绑定 dom的属性123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;p v-html = \"h\"&gt;&lt;/p&gt; &lt;p v-text = \"msg\"&gt;&lt;/p&gt; &lt;p v-text = \" flag && 1 || 2 \" &gt; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; /* 案例： v-html 分析： 发现dom元素直接有了一个内容 这种属性绑定就是为了操作dom 结论： 这种属性绑定的形式就是为了操作dom，我们给这种属性起了一个好听的名字 Vue 1.0 叫它 属性指令（ 借鉴Angular来的 ） Vue 2.0 统称为 ‘指令’ 指令是用一个 v-xxx 表示 指令是用来操作dom Vue中不允许直接操作dom!!! mustache语法 --- 属性写法 的属性值是直接写数据的，不需要使用 {{ }} */var vm = new Vue({ el: '#app', data: { msg: 'hello Vue.js', h: '&lt;h3&gt; hello Vue.js &lt;/h3&gt;', flag: true } })&lt;/script&gt; 问题： 我们说vue是 MVVM 框架， 那么谁是 M 谁是 V 谁是 VM 1234567891011121314151617&lt;!-- V --&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script&gt; /* M： Model 数据 V： View 视图 VM: ViewModel 视图模型（ new Vue() ） */ var vm = new Vue({ el: '#app',//给跟实例一个模板（ 挂载 ） data: { //M } })&lt;/script&gt; 指令： ( 是绑定在dom属性上 )v-html:可以解析标签型数据( 可以将一个数据展示在一个dom的内容中（ 相当于使用了 innerHTML ）) v-text：可以将一个数据展示在一个dom的内容中（ 相当于使用了 innerHTML ）条件渲染的指令 v-show可以控制一个dom的显示隐藏（ 这个指令操作的是dom的display属性 ） v-if可以控制一个dom的存在与否（ 创建 和 销毁 ） v-elsev-else-if123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;h3&gt; v-show &lt;/h3&gt; &lt;p v-show = \"showFlag\"&gt; v-show指令 &lt;/p&gt; &lt;hr&gt; &lt;h3&gt; v-if - 单路分支 &lt;/h3&gt; &lt;p v-if = \"ifFlag\"&gt; v-if - 指令的单路分支 &lt;/p&gt; &lt;h3&gt; v-if - 双路分支 &lt;/h3&gt; &lt;p v-if = \"ifFlag\"&gt; 双路分支 成立 &lt;/p&gt; &lt;p v-else&gt; 双路分支不成立 &lt;/p&gt; &lt;h3&gt; v-if - 多路分支 &lt;/h3&gt; &lt;p v-if = \" type === 'A'\"&gt; A &lt;/p&gt; &lt;p v-else-if = \" type === 'B'\"&gt; B &lt;/p&gt; &lt;p v-else&gt; C &lt;/p&gt; &lt;/div&gt;&lt;script&gt;var vm = new Vue({ el: '#app',//给跟实例一个模板（ 挂载 ） data: { showFlag: true, ifFlag: false, type: 'A' }})&lt;/script&gt; 实用题 v-if vs v-show 区别 实用： 项目中 如何选择这两个使用 v-if 操作的是dom元素（ 组件 ） 的创建或是销毁 v-show 操作的是dom元素的display属性 v-if可以有多种使用形式： 单路分支， 多路分支， 双路分支 v-show 只能写一个单路形式一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-for 数组 v-for = “ (item,index) in arr “ item是arr中每一个元素 对象 v-for = “(item,key,index) in obj “ item是obj的属性值 json类型数据 嵌套类型数据 key:给没一个循环的列表添加一个唯一的标识使用指令 v-bind 来绑定 key如果有id，那么我们就使用id，如果没有，我们才会选择indexv-bind: 单项数据绑定： 将一个数据绑定在一个dom的属性上简写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;div id=\"app\"&gt; &lt;h3&gt; 数组 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \" (item,index) in arr \" v-bind:key = \"index\"&gt; &lt;p&gt; item :{{ item }} -- index: {{ index }}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; 对象 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \"(item,key,index) in obj\" v-bind:key = \"index\"&gt; &lt;p&gt; value: {{ item }} -- key: {{ key }} -- {{ index }} &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; json &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \"(item,index) of json\" v-bind:key = \" item.id \"&gt; &lt;p&gt; id: {{ item.id }} &lt;/p&gt; &lt;p&gt; task: {{ item.task }} &lt;/p&gt; &lt;p&gt; {{ index }} &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; 嵌套 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \" item in lists \" :key = \"item.id\"&gt; &lt;p&gt; id: {{ item.id }} &lt;/p&gt; &lt;ul&gt; &lt;li v-for = \"todo in item.todos\"&gt; todos中的数据 -- {{ todo }} &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { arr: [1,2,3,4], obj: { id: 1, name: '骏哥', sex: 'man', age: 18 }, json: [ { id: 1, task: '敲代码1' }, { id: 2, task: '敲代码2' } ], lists: [ { id: 1, todos: { id: 1, name: '连城' } }, { id: 2, todos: { id: 2, name: '文武' } } ] } })&lt;/script&gt; vue中如何给dom添加类名 直接在dom上绑定类名 vue中类名绑定 - 对象形式目的： dom身上属性class 要和 数据绑定解决：v-bind数据中key，我们起的和绑定的对象中的key一样，但是你得知道这两个东西不一样&lt;p :class = \"{ size,bg_color }\"&gt;&lt;/p&gt;size是自定义的属性， 它的属性值是undefined， 相当于是false&lt;p :class = \"{ size: true, bg_color: true }\"&gt;&lt;/p&gt;size也是自定义属性，他的属性是true,那么就会加上去&lt;p :class = \"{ [s]: true, [bg_color]: true }\"&gt;&lt;/p&gt;格式： v-bind:class = \"{ 属性： boolean }\"格式： v-bind:class = \"{ [data]： boolean }\" vue中类名绑定的形式 - 数组的形式 【 推荐 】格式： v-bind:class = \"[ 数据 ]\" 类名绑定不会覆盖原先的类名 为什么要绑定类名指令是用来操作dom目的： 为了将来通过数据来操作类名，类名操作dom12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; .size{ width: 100px; height: 100px; } .bg_color{ background: red; }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;h3&gt; v-class &lt;/h3&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加第一种 &lt;/h3&gt; &lt;p class=\"size bg_color\"&gt;&lt;/p&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加第二种 - 对象的形式&lt;/h3&gt; &lt;p :class = \"{ size: true,bg_color: false }\"&gt;&lt;/p&gt; &lt;p :class = \"{ size: true, bg_color: true }\"&gt;&lt;/p&gt; &lt;p :class = \"{ [s]: true, [bg_color]: true }\"&gt;&lt;/p&gt; &lt;p :class = \"{ [s]: 5&gt;3?true: false, [bg_color]: true }\"&gt;&lt;/p&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加的第三种形式 - 数组形式（ 推荐 ）&lt;/h3&gt; &lt;p :class = \"['size','bg_color']\"&gt;&lt;/p&gt; &lt;p :class = \"[ s, bg_color ]\"&gt;&lt;/p&gt; &lt;p :class = \"[ flag? s:'box', bg_color]\"&gt;&lt;/p&gt; &lt;p :class = \"[ flag? s:'box', bg_color]\" class = \"yyb\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data: { msg: 'hello Vue.js', s: 'size', bg_color: 'bg_color', flag: true } }); var a = { name: 'yhk' } var b = { name: 'mjn' }&lt;/script&gt; 样式的绑定：v-bind:style = “” 对象的形式 数组的形式12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;h3&gt; style &lt;/h3&gt; &lt;hr&gt; &lt;h3&gt; style - 对象形式 &lt;/h3&gt; &lt;p :style = \"{ width: size.width,height: size.height,background: 'red'}\"&gt;&lt;/p&gt; &lt;h3&gt; style - 数组的形式 &lt;/h3&gt; &lt;p :style = \"[ { width: '100px',background: 'blue'},{ height: '100px' } ]\"&gt; &lt;/p&gt; &lt;p :style = \"[ size,bg ]\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { size: { width: '100px', height: '100px' }, bg: { background: 'purple' } } })&lt;/script&gt; 事件问题： javascript事件添加有几种形式 事件绑定dom.onclick = function () {}dom: 事件源on: 绑定事件的形式click: 事件类型function（）{} 事件处理函数 事件监听 ：addeventListener 直接在标签中绑定事件&lt;div onclick = \"事件名称\"&gt;&lt;/div&gt;vue采用了第三种，也是通过属性的形式绑定在dom身上&lt;div v-on:click = \"事件名称\"&gt;&lt;/div&gt;简写：&lt;button @click = \"helloHandler\"&gt; 点击 &lt;/button&gt;v-on使用事件源事件绑定形式事件类型事件处理程序v-on:eventType = “ handlerName “简写 v-on: — > @ 问题： 函数调用有哪些方法？直接调用 ()事件事件对象也可以正常使用在事件处理程序中， 写e就可以了问题： 如果事件处理程序中有三个参数，第三个参数才是事件对象e,如何实现分析： 我们发现事件处理程序中的第三个参数 e 不在是事件对象了，而是一个undefined解决： 在函数执行时，传入一个实际参数 $event 来代表事件对象 问题： 如果我们通过 length = 0 , 来清空一个数组，那么vue检测不到这个变动解决方法： 使用splice问题： 我们直接修改一个数组下的一个数据时，发现下标不能检测变动了解决方法： 使用 Vue.set / this.$set 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;div id=\"app\"&gt; &lt;button @click = \"add\"&gt; + &lt;/button&gt; &lt;button @click = \"remove\"&gt; - &lt;/button&gt; &lt;button @click = \"indexHandler\"&gt; 修改第二条数据 &lt;/button&gt; &lt;ul&gt; &lt;li v-for =\" item in lists \" :key = \"item.id\"&gt; {{ item.task }} &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;button @click = \"arrChange\"&gt; 修改第二条数据 &lt;/button&gt; &lt;ul&gt; &lt;li v-for = \" (item,index ) in arr \" :key = \"index\"&gt; {{ item }} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;/*业务： 点击这个按钮，添加一条新的数据放在列表数据中*/new Vue({ el: '#app', data: { arr: [1,2,3], lists: [ { id: 1, task: '锻炼1' }, { id: 2, task: '敲代码' } ] }, methods: { add () { // console.log( this ) this.lists.push({ id: this.lists.length + 1, task: '打篮球' }) }, remove () { this.lists.pop() }, indexHandler () { //将列表中的第二个数据中的task任务修改为 撸猫 this.lists[1] = { id: 2, task: '骏哥' } // 将整个列表清空 // this.lists.length = 0 // this.lists.splice( 0 ) }, arrChange () { // this.arr[ 1 ] = '骏哥' 不可以检测到的 // this.$set( this.arr,'1','骏哥' ) Vue.set( this.arr,'1','骏哥') } } })&lt;/script&gt; v-model双向数据绑定默认绑定value值v-model应用于表单元素 1234567891011121314&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model = \"msg\"&gt; &lt;p&gt; {{ msg }} &lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: 'hello Vue.js' } })&lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"}]}]