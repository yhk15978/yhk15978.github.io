[{"title":"前端异步流程","date":"2019-06-21T11:20:20.187Z","path":"/posts/4a17b158/","text":"前端异步流程1. 传统的原生异步- 回调函数 - 事件2. 使用异步流程工具（ 别人封装好的东西 ）- es6 Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* Promise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise 所谓Promise ，简单说就是一个容器，里面保存着某个未来才回结束的事件(通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。 Promise 对象的状态不受外界影响 三种状态: pending：进行中 fulfilled :已经成功 rejected 已经失败 状态改变： Promise对象的状态改变，只有两种可能： 从pending变为fulfilled 从pending变为rejected。 这两种情况只要发生，状态就凝固了，不会再变了，这时就称为resolved（已定型）*/ const p1 = new Promise((resolve, reject) => { resolve('任务一') }).then(data => { console.log(data); return data; }) const p3 = new Promise((resolve, reject) => { setTimeout(() => { resolve('任务三') }, 1000) }).then(data => { console.log(data); return data; }) const p2 = new Promise((resolve, reject) => { setTimeout(() => { resolve('任务二') }, 2000) }).then(data => { console.log(data) return data }) console.log('主线程任务') //主线程任务 // all race // 如果作为参数的Promise实例自身定义了catch方法，那么它被rejected是并不会触发Promise.all()的catch方法 // Promise.all中都成功返回才执行 Promise.all([p1, p2, p3]).then(data => { //data为p1,p2,p3返回值组成的数组 console.log(data) //[ '任务一', '任务二', '任务三' ] }).catch(e => console.log(e)) // Promise.race中只要有一个成功返回就执行 Promise.race([p1, p2, p3]).then(data => { //data为p1,p2,p3中最先成功的返回值 console.log(data) //任务一 }) // 以上代码执行结果为 // 主线程任务 // 任务一 // 任务一 // 任务三 // 任务二 // [ '任务一', '任务二', '任务三' ] - es6 generator函数123456789101112131415161718192021/*generator函数在function关键字后面加一个* 这样定义的函数就叫做generator函数通过yield关键字来定义任务通过fn().next() 来执行任务value表示yield关键字后任务执行的结果done表示当前定义的所有的任务是否执行完成的一个状态理解：多任务的定义，多任务执行让自己定义的多个任务依次执行，上一个任务如果没有完成，下一个任务就不会开始*/function* fn() {yield '任务一'yield '任务二'return '任务'}const a = fn()console.log(a.next()) // { value: '任务一'，done: false }console.log(a.next()) //{ value: '任务二', done: false }console.log(a.next()) //{ value: '任务', done: true }console.log('主线程任务') //主线程任务 es6( 7 ) async 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*async函数es6提供配合关键字 await使用await 表示，等待，任务一执行结束之后，才会执行任务二async函数返回值为Promise对象*/async function fn() { const result = await '任务一' console.log(result) console.log('任务二')}fn()const fn1 = async() => {const res = await new Promise((res, rej) => { setTimeout(() => { res('任务3') }, 2000) }).then(result => { console.log(result) return result;})let req = await new Promise((res, rej) => { setTimeout(() => { res('任务四') }, 1000) }).then(result => { console.log(result) return result;}) console.log(req) console.log(res)if (false) { return req} else { throw res}//返回值通过then()调用，抛出值通过catch()调用}fn1().then(re => console.log(re)).catch(re => console.log(re))//结果:// 任务一// 任务二// 任务3// 任务四// 任务四// 任务3// 任务3 - node.js中的 nextTick setImmudiate 1234567nextTick()的回调函数执行的优先级要高于setImmediate();process.nextTick()属于idle观察者,setImmediate()属于check观察者.在每一轮循环检查中,idle观察者先于I/O观察者,I/O观察者先于check观察者.在具体实现上,process.nextTick()的回调函数保存在一个数组中,setImmediate()的结果则是保存在链表中.在行为上,process.nextTick()在每轮循环中会将数组中的回调函数全部执行完.而setImmediate()在每轮循环中执行链表中的一个回调函数.nextTick > 回调函数 > setImmediate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*Node.js提供的nextTicksetImmediate*///加入2个nextTick()的回调函数process.nextTick(function(){ console.log(\"nextTick延迟执行A\");});process.nextTick(function(){ console.log(\"nextTick延迟执行B\");setImmediate(function(){ console.log(\"setImmediate延迟执行C\");});process.nextTick(function(){ console.log(\"nextTick延迟执行D\");});});//加入两个setImmediate()回调函数setImmediate(function(){ console.log(\"setImmediate延迟执行E\");process.nextTick(function(){ console.log(\"强势插入F\");});setImmediate(function(){ console.log(\"setImmediate延迟执行G\");});});setImmediate(function(){ console.log(\"setImmediate延迟执行H\");process.nextTick(function(){ console.log(\"强势插入I\");});process.nextTick(function(){ console.log(\"强势插入J\");});setImmediate(function(){ console.log(\"setImmediate延迟执行K\");});});console.log(\"正常执行L\");// 正常执行L// nextTick延迟执行A// nextTick延迟执行B// nextTick延迟执行D// setImmediate延迟执行E// setImmediate延迟执行H// setImmediate延迟执行C// 强势插入F// 强势插入I// 强势插入J// setImmediate延迟执行G// setImmediate延迟执行K - 第三方的 async.js 库 12345678910111213141516171819202122232425262728293031323334353637383940414243/*async.js第三方的库案例：parallelseries功能：1. 可以实现异步2. 串行series和并行parallel*/const async = require( 'async' ) async.series({ one: function ( callback ) { setTimeout( function () { callback( null, 1)},200)},two: function ( callback ) {setTimeout( function () { callback ( null , 2 )},100)}}, function ( error , results ) { console.log( 'series',results )}) console.log( '主线程' )async.parallel({ one: function ( callback ) {setTimeout( function () { callback( null, 1)},200)},two: function ( callback ) { setTimeout( function () { callback ( null , 2 )},100)}}, function ( error , results ) { console.log( 'parallel',results )}) // 主线程// parallel { two: 2, one: 1 }// series { one: 1, two: 2 } 总结： 异步流程的任务是放在异步队列中的，异步队列只有在主线程执行完之后采取执行 参考资料 Promisehttps://blog.csdn.net/MrJavaweb/article/details/79475949 Generatorhttps://www.cnblogs.com/imwtr/p/5913294.html Async-await Node.js 中的nextTick()和setimmediate()https://www.cnblogs.com/5ishare/p/5268273.html async库https://caolan.github.io/async/参考文档Event-loophttp://www.ruanyifeng.com/blog/2014/10/event-loop.html?bsh_bid=983729729史上最易读懂的 Promise/A+ 完全实现https://zhuanlan.zhihu.com/p/21834559 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"},{"name":"node","slug":"node","permalink":"https://yhk15978.github.io/tags/node/"},{"name":"js","slug":"js","permalink":"https://yhk15978.github.io/tags/js/"}]},{"title":"vue基础语法","date":"2019-06-19T11:59:36.232Z","path":"/posts/4a17b157/","text":"vue基础语法mutache 语法糖123456&lt;div id=\"app\"&gt; &lt;p&gt; {{ this.msg }} &lt;/p&gt; &lt;p&gt; {{ this.$data.msg }} &lt;/p&gt; &lt;p&gt; {{ this._data.msg }} &lt;/p&gt; &lt;p&gt; {{ msg }} &lt;/p&gt;&lt;/div&gt; jsx: javascript + xml可以让我们在dom结构中输写javascript 是 this.msg 简写this.$data.msg -> this.msg -> msg mustache语法糖对数据类型的支持（ js语法的支持 ）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt; number: {{ num }} &lt;/p&gt; &lt;p&gt; string: {{ str }} &lt;/p&gt; &lt;p&gt; boolean: {{ bool }} &lt;/p&gt; &lt;p&gt; null: {{ nul?'1':'2' }} &lt;/p&gt; &lt;p&gt; undefined: {{ und && 1 || 2 }} &lt;/p&gt; &lt;p&gt; object: {{ obj.name }} &lt;/p&gt; &lt;p&gt; array: {{ arr[0] }} &lt;/p&gt; &lt;p&gt; fn: {{ fn() }} &lt;/p&gt; &lt;!-- &lt;p&gt; console.log: {{ console.log( 1 ) }} &lt;/p&gt; &lt;p&gt; alert: {{ alert( 2 ) }} &lt;/p&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; /* 数据类型： 第一种划分： 基础数据类型： number string boolean 复杂数据类型: Object( array function ) 特殊数据类型: null undefined 第二种划分： 初始数据类型: number string boolean null undefined 引用数据类型: object( array function ) 结论： mustache支持我们js的数据类型的 conosle.log 和 alert 在我们mustache语法中是不支持的 */var vm = new Vue({ el: '#app', data: { num: 100, str: 'hello Vue.js', bool: true, nul: null, und: undefined, obj: { name: 'yhk' }, arr: [1,2,3,4], fn: function () { alert( 2 ) return '这是一个函数' } }})&lt;/script&gt; mustache 绑定 dom的属性123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;p v-html = \"h\"&gt;&lt;/p&gt; &lt;p v-text = \"msg\"&gt;&lt;/p&gt; &lt;p v-text = \" flag && 1 || 2 \" &gt; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; /* 案例： v-html 分析： 发现dom元素直接有了一个内容 这种属性绑定就是为了操作dom 结论： 这种属性绑定的形式就是为了操作dom，我们给这种属性起了一个好听的名字 Vue 1.0 叫它 属性指令（ 借鉴Angular来的 ） Vue 2.0 统称为 ‘指令’ 指令是用一个 v-xxx 表示 指令是用来操作dom Vue中不允许直接操作dom!!! mustache语法 --- 属性写法 的属性值是直接写数据的，不需要使用 {{ }} */var vm = new Vue({ el: '#app', data: { msg: 'hello Vue.js', h: '&lt;h3&gt; hello Vue.js &lt;/h3&gt;', flag: true } })&lt;/script&gt; 问题： 我们说vue是 MVVM 框架， 那么谁是 M 谁是 V 谁是 VM 1234567891011121314151617&lt;!-- V --&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script&gt; /* M： Model 数据 V： View 视图 VM: ViewModel 视图模型（ new Vue() ） */ var vm = new Vue({ el: '#app',//给跟实例一个模板（ 挂载 ） data: { //M } })&lt;/script&gt; 指令： ( 是绑定在dom属性上 )v-html:可以解析标签型数据( 可以将一个数据展示在一个dom的内容中（ 相当于使用了 innerHTML ）) v-text：可以将一个数据展示在一个dom的内容中（ 相当于使用了 innerHTML ）条件渲染的指令 v-show可以控制一个dom的显示隐藏（ 这个指令操作的是dom的display属性 ） v-if可以控制一个dom的存在与否（ 创建 和 销毁 ） v-elsev-else-if123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;h3&gt; v-show &lt;/h3&gt; &lt;p v-show = \"showFlag\"&gt; v-show指令 &lt;/p&gt; &lt;hr&gt; &lt;h3&gt; v-if - 单路分支 &lt;/h3&gt; &lt;p v-if = \"ifFlag\"&gt; v-if - 指令的单路分支 &lt;/p&gt; &lt;h3&gt; v-if - 双路分支 &lt;/h3&gt; &lt;p v-if = \"ifFlag\"&gt; 双路分支 成立 &lt;/p&gt; &lt;p v-else&gt; 双路分支不成立 &lt;/p&gt; &lt;h3&gt; v-if - 多路分支 &lt;/h3&gt; &lt;p v-if = \" type === 'A'\"&gt; A &lt;/p&gt; &lt;p v-else-if = \" type === 'B'\"&gt; B &lt;/p&gt; &lt;p v-else&gt; C &lt;/p&gt; &lt;/div&gt;&lt;script&gt;var vm = new Vue({ el: '#app',//给跟实例一个模板（ 挂载 ） data: { showFlag: true, ifFlag: false, type: 'A' }})&lt;/script&gt; 实用题 v-if vs v-show 区别 实用： 项目中 如何选择这两个使用 v-if 操作的是dom元素（ 组件 ） 的创建或是销毁 v-show 操作的是dom元素的display属性 v-if可以有多种使用形式： 单路分支， 多路分支， 双路分支 v-show 只能写一个单路形式一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-for 数组 v-for = “ (item,index) in arr “ item是arr中每一个元素 对象 v-for = “(item,key,index) in obj “ item是obj的属性值 json类型数据 嵌套类型数据 key:给没一个循环的列表添加一个唯一的标识使用指令 v-bind 来绑定 key如果有id，那么我们就使用id，如果没有，我们才会选择indexv-bind: 单项数据绑定： 将一个数据绑定在一个dom的属性上简写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;div id=\"app\"&gt; &lt;h3&gt; 数组 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \" (item,index) in arr \" v-bind:key = \"index\"&gt; &lt;p&gt; item :{{ item }} -- index: {{ index }}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; 对象 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \"(item,key,index) in obj\" v-bind:key = \"index\"&gt; &lt;p&gt; value: {{ item }} -- key: {{ key }} -- {{ index }} &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; json &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \"(item,index) of json\" v-bind:key = \" item.id \"&gt; &lt;p&gt; id: {{ item.id }} &lt;/p&gt; &lt;p&gt; task: {{ item.task }} &lt;/p&gt; &lt;p&gt; {{ index }} &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;h3&gt; 嵌套 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for = \" item in lists \" :key = \"item.id\"&gt; &lt;p&gt; id: {{ item.id }} &lt;/p&gt; &lt;ul&gt; &lt;li v-for = \"todo in item.todos\"&gt; todos中的数据 -- {{ todo }} &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { arr: [1,2,3,4], obj: { id: 1, name: '骏哥', sex: 'man', age: 18 }, json: [ { id: 1, task: '敲代码1' }, { id: 2, task: '敲代码2' } ], lists: [ { id: 1, todos: { id: 1, name: '连城' } }, { id: 2, todos: { id: 2, name: '文武' } } ] } })&lt;/script&gt; vue中如何给dom添加类名 直接在dom上绑定类名 vue中类名绑定 - 对象形式目的： dom身上属性class 要和 数据绑定解决：v-bind数据中key，我们起的和绑定的对象中的key一样，但是你得知道这两个东西不一样&lt;p :class = \"{ size,bg_color }\"&gt;&lt;/p&gt;size是自定义的属性， 它的属性值是undefined， 相当于是false&lt;p :class = \"{ size: true, bg_color: true }\"&gt;&lt;/p&gt;size也是自定义属性，他的属性是true,那么就会加上去&lt;p :class = \"{ [s]: true, [bg_color]: true }\"&gt;&lt;/p&gt;格式： v-bind:class = \"{ 属性： boolean }\"格式： v-bind:class = \"{ [data]： boolean }\" vue中类名绑定的形式 - 数组的形式 【 推荐 】格式： v-bind:class = \"[ 数据 ]\" 类名绑定不会覆盖原先的类名 为什么要绑定类名指令是用来操作dom目的： 为了将来通过数据来操作类名，类名操作dom12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; .size{ width: 100px; height: 100px; } .bg_color{ background: red; }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;h3&gt; v-class &lt;/h3&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加第一种 &lt;/h3&gt; &lt;p class=\"size bg_color\"&gt;&lt;/p&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加第二种 - 对象的形式&lt;/h3&gt; &lt;p :class = \"{ size: true,bg_color: false }\"&gt;&lt;/p&gt; &lt;p :class = \"{ size: true, bg_color: true }\"&gt;&lt;/p&gt; &lt;p :class = \"{ [s]: true, [bg_color]: true }\"&gt;&lt;/p&gt; &lt;p :class = \"{ [s]: 5&gt;3?true: false, [bg_color]: true }\"&gt;&lt;/p&gt; &lt;hr&gt; &lt;h3&gt; vue中类名添加的第三种形式 - 数组形式（ 推荐 ）&lt;/h3&gt; &lt;p :class = \"['size','bg_color']\"&gt;&lt;/p&gt; &lt;p :class = \"[ s, bg_color ]\"&gt;&lt;/p&gt; &lt;p :class = \"[ flag? s:'box', bg_color]\"&gt;&lt;/p&gt; &lt;p :class = \"[ flag? s:'box', bg_color]\" class = \"yyb\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data: { msg: 'hello Vue.js', s: 'size', bg_color: 'bg_color', flag: true } }); var a = { name: 'yhk' } var b = { name: 'mjn' }&lt;/script&gt; 样式的绑定：v-bind:style = “” 对象的形式 数组的形式12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;h3&gt; style &lt;/h3&gt; &lt;hr&gt; &lt;h3&gt; style - 对象形式 &lt;/h3&gt; &lt;p :style = \"{ width: size.width,height: size.height,background: 'red'}\"&gt;&lt;/p&gt; &lt;h3&gt; style - 数组的形式 &lt;/h3&gt; &lt;p :style = \"[ { width: '100px',background: 'blue'},{ height: '100px' } ]\"&gt; &lt;/p&gt; &lt;p :style = \"[ size,bg ]\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { size: { width: '100px', height: '100px' }, bg: { background: 'purple' } } })&lt;/script&gt; 事件问题： javascript事件添加有几种形式 事件绑定dom.onclick = function () {}dom: 事件源on: 绑定事件的形式click: 事件类型function（）{} 事件处理函数 事件监听 ：addeventListener 直接在标签中绑定事件&lt;div onclick = \"事件名称\"&gt;&lt;/div&gt;vue采用了第三种，也是通过属性的形式绑定在dom身上&lt;div v-on:click = \"事件名称\"&gt;&lt;/div&gt;简写：&lt;button @click = \"helloHandler\"&gt; 点击 &lt;/button&gt;v-on使用事件源事件绑定形式事件类型事件处理程序v-on:eventType = “ handlerName “简写 v-on: — > @ 问题： 函数调用有哪些方法？直接调用 ()事件事件对象也可以正常使用在事件处理程序中， 写e就可以了问题： 如果事件处理程序中有三个参数，第三个参数才是事件对象e,如何实现分析： 我们发现事件处理程序中的第三个参数 e 不在是事件对象了，而是一个undefined解决： 在函数执行时，传入一个实际参数 $event 来代表事件对象 问题： 如果我们通过 length = 0 , 来清空一个数组，那么vue检测不到这个变动解决方法： 使用splice问题： 我们直接修改一个数组下的一个数据时，发现下标不能检测变动了解决方法： 使用 Vue.set / this.$set 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;div id=\"app\"&gt; &lt;button @click = \"add\"&gt; + &lt;/button&gt; &lt;button @click = \"remove\"&gt; - &lt;/button&gt; &lt;button @click = \"indexHandler\"&gt; 修改第二条数据 &lt;/button&gt; &lt;ul&gt; &lt;li v-for =\" item in lists \" :key = \"item.id\"&gt; {{ item.task }} &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;button @click = \"arrChange\"&gt; 修改第二条数据 &lt;/button&gt; &lt;ul&gt; &lt;li v-for = \" (item,index ) in arr \" :key = \"index\"&gt; {{ item }} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;/*业务： 点击这个按钮，添加一条新的数据放在列表数据中*/new Vue({ el: '#app', data: { arr: [1,2,3], lists: [ { id: 1, task: '锻炼1' }, { id: 2, task: '敲代码' } ] }, methods: { add () { // console.log( this ) this.lists.push({ id: this.lists.length + 1, task: '打篮球' }) }, remove () { this.lists.pop() }, indexHandler () { //将列表中的第二个数据中的task任务修改为 撸猫 this.lists[1] = { id: 2, task: '骏哥' } // 将整个列表清空 // this.lists.length = 0 // this.lists.splice( 0 ) }, arrChange () { // this.arr[ 1 ] = '骏哥' 不可以检测到的 // this.$set( this.arr,'1','骏哥' ) Vue.set( this.arr,'1','骏哥') } } })&lt;/script&gt; v-model双向数据绑定默认绑定value值v-model应用于表单元素 1234567891011121314&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model = \"msg\"&gt; &lt;p&gt; {{ msg }} &lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: 'hello Vue.js' } })&lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Vue","slug":"Vue","permalink":"https://yhk15978.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yhk15978.github.io/tags/前端/"}]},{"title":"Hello World","date":"2019-06-18T13:33:32.075Z","path":"/posts/4a17b156/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]}]